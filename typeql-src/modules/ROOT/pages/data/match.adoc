= Match clause
:Summary: Matching data with patterns
:keywords: typeql, typedb, query, match, matching, data, pattern, statement, variable, answer
:pageTitle: Match clause
:!table-caption:

A `match` clause seeks data in a TypeDB database.

This clause is widely used in data queries: it is mandatory in
xref:data/fetch.adoc[Fetch],
xref:data/get.adoc[Get],
xref:data/delete.adoc[Delete], and
xref:data/update.adoc[Update], but optional in an
xref:data/insert.adoc[Insert] query.

== Behavior

A `match` clause is used to seek existing concepts in a database by a pattern.
A concept can be a data instance or a type.

The result of a `match` clause is a set of answers corresponding to a given pattern.
Every answer contains a concept for every <<_concept_variable,concept variable>> and a value for every
<<_value_variables,value variable>> used in a pattern of a `match` clause.
//Every answer makes that pattern a true statement, according to database's data and schema.
//These answers confirm the truth of the pattern based on the database's data and schema.

You can think of matching a pattern as solving a system of equations,
where every equation is a single statement in a pattern.
TypeDB solves the system and returns all its solutions.

== Syntax

Match clauses are written in TypeQL with the following syntax:

[,typeql]
----
match <pattern>
----

A `match` clause can use all existing patterns that are valid, according to a database's schema.
A pattern used in a `match` clause can address both schema types and data instances.

== Match clause results

The *result* of a `match` clause with any pattern is a *set of solutions found*.
The length of the set is equal to the number of solutions found.
Hence, it can be zero -- No solutions found (nothing matched the pattern). Empty set returned.
* One -- Exactly one solution found and returned in a set.
* Many -- Multiple solutions found, including all possible permutations. All of them returned in a set.

For example, in the <<_statement-structure,statement>> illustrated above, TypeDB will find all solutions that include a
`person` entity that has a `full-name` attribute with the value `Masako Holley` and has any email.

What if no `person` entity has this particular name in a database? Then a set of zero solutions (answers)
will be returned, regardless of the emails.

What if there is one `person` with the `full-name` attribute like that, but it has two `email` attributes?
Then TypeDB will find *two* solutions/answers. And every answer will include that one `person` entity and one of the
emails.

[IMPORTANT]
====
A `match` clause returns all possible <<_solutions, solutions>> (combinations of variables values that make a `true`
statement from the pattern), including all possible permutations. It's vital to understand how a `match` clause
matches patterns. Especially if it's used as a part of an insert or a delete query because the `insert` or the `delete`
clause in these will be executed once for every matched result from the `match` clause used.

For example, we match all instances of *two* types without any constraints.
Let's say one of the types has **two** instances, and the other one has **ten**. Then the `match` clause returns
all matched combinations, including all permutations: **20 results** in total. The first instance og the
====
// end::patterns_overview[]

// tag::variables[]
[#_variables]
== Variables

There are two types of variables:

[#_concept_variable]
* Concept variable -- used *by default* in most queries. It references a concept (an instance of data or a type).
[#_value_variable]
* Value variable -- used only in computation, like <<_arithmetic_operations,arithmetic operations>>
  and other <<_built_in_functions,built-in functions>> requiring direct operation on values.

A concept variable starts with the dollar sign `$` followed by a variable label (for example, `$x`) and references
exactly one concept (type or data) per every answer (solution) found for a pattern.

A value variable starts with question mark `?` followed by variable label (for example, `?x`) and reference exactly
one value per every answer (solution) found for a pattern. See <<_value_variables>> below.
// end::variables[]

[#_comparison_operators]
=== Comparison operators

The following operators are supported for comparing attribute values: `==`, `!=`, `>`, `>=`, `<`, and `+<=+`.

[WARNING]
====
In TypeDB version `2.18.0`, the `=` sign as a comparison operator was *deprecated*, as it is now being used to assign
values to value variables.

We recommend using `==` for comparison instead.

The old syntax, for example:

[,typeql]
----
$p = $u;
----

will be supported for backwards compatibility for a limited time (if it's used with a concept variable on the left from
the `=` sign).

It will be removed from the TypeQL syntax in later versions of TypeDB.
====

[#_value_variables]
=== Value variables

In addition to the default concept variables that address concepts inside a TypeDB database, a special variable type
is used only for <<_computation,computation>>.

They are called Value variables.

Instead of the dollar sign (e.g., `$p`), value variables use the question mark (e.g., `?x`) preceding the variable label.

Instead of concepts, value variables represent exact value in a pattern.

To set a value variable with some value, we can use the `=` sign: with the value variable on the left from it and on the
right side -- we shall have an <<_expression,expression>>.
Value variables are never materialized permanently and
are only used within the scope of a particular query or rule.

To persist the value of a value variable, we can use an attribute type with a matching value type.
Value variables can be one of the following value types (the same as value types for attributes):

* `long`
* `double`
* `boolean`
* `string`
* `datetime`
** `yyyy-mm-dd`
** `yyyy-mm-ddThh:mm`
** `yyyy-mm-ddThh:mm:ss`
** `yyyy-mm-ddThh:mm:ss.f`
** `yyyy-mm-ddThh:mm:ss.ff`
** `yyyy-mm-ddThh:mm:ss.fff`

[#_expression]
An *expression* describes a computation of the value for a value variable. It contains any combination of the following
elements:

* constant, set in a query (e.g., `?x = 4`),
* value of a concept variable (it should be an attribute to have a value) or value variable bound in the query,
* <<_arithmetic_operations,arithmetic operation>>,
* other <<_built_in_functions,built-in function>>.

.See an example of a query with expression
[%collapsible]
====
[,typeql]
----
match
  $s isa size-kb;
  ?x = round($s/2) + 1;
----

The query above will find all instances of data for the `size-kb` attribute type for a concept variable `$s`.
For a value variable `?x`, we divide the value of the instance of the attribute in `$s` by a constant value `2`,
rounding it, and adding `1` to the result. Hence, every result for this query consists of `$s` and `?x`:

* `$s` equals to a value of an attribute of `size-kb` type,
* `?x` equals the result of the computation described in the query, which depends on the attribute's value.

====

// tag::patterns_body[]
// tag::patterns_overview[]
[#_patterns_overview]
== Patterns overview

TypeDB is using TypeQL query language with declarative and composable patterns.

A pattern is a set of statements combined by an implicit conjunction (logical "AND").
Hence, patterns are composable,
meaning you can combine two patterns by using their statements together in a new pattern.

Statements declare constraints for types and data.
They consist of variables, keywords, types, and values.
All statements must end with a semicolon.

See below an example of a statement that describes a person, that has specified full-name and unspecified email.

[#_statement-structure]
image::statement-structure.png[Statement structure]

The above pattern contains a single statement that includes a variable (marked as `V`)
followed by a comma-separated list of constraints (`p1`, `p2`, and `p3`) describing the concepts the variable refers to.
The same pattern can be translated to a natural language as the following:

`$p`
is an instance of type `person`,
that has attribute of type `full-name` and value `Masako Holley`
and has an attribute of type `email` with unspecified value, that we will further reference as `$email`.

Instead of using a comma-separated list of three constraints in a single statement,
the same pattern can be represented by three distinct simple statements combined by a conjunction:

.Example of simple statements
[,typeql]
----
$p isa person;
$p has full-name "Masako Holley";
$p has email $email;
----

There are two major subsets of patterns:
<<_data_patterns,data patterns>> (e.g., `isa` pattern) and
<<_type_patterns,type patterns>> (e.g., `sub` pattern).

[#_data_patterns]
=== Data patterns

Data patterns are used for data instances.
They can be used only in data queries and xref:typeql::schema/define-rules.adoc[rules].
//#todo Add link to the Data queries page

.Data patterns
[cols="^.^1,^.^2,^.^2"]
|===
| Pattern name | *Pattern syntax* | *Examples*

| Instance of a type or a subtype
| `+$<var> isa <type>;+`
| `$p isa person;`

| Instance of a type
| `+$<var> isa! <type>;+`
| `$p isa! person;`

| Instance of an attribute type
| `+$<var> (isa[!] <attr-type> \| contains "<text>"  like "<regex>" \| [<comparator>] <value>);+`
a|
* `$a "Kevin Morrison";`
* `$b isa full-name;`
* `$c contains "Kevin";`

| Instance of a relation
| `+[$<var>] ([<role>:] $<var> [, [<role>:] $<var>]...) isa <relation-type>;+`
| `$pe (subject: $p, access: $ac) isa permission, has validity true;`

| has-attribute statement
| `+has <attr-type> ($<var> \| [<comparison-operator>] <value> );+`
| `$f has size-kb > 300;`

| comparison
| `$<var> [<comparison-operator>] <value>;`
| `$a > 300; $f has size-kb $a;`

| equal
| `$<var1> is $<var2>;`
| `$p has $a; $t isa entity; $t is $p; get $t;`
|===

For more information on
xref:typeql::data/match.adoc#_comparison_operators[comparison operators],
xref:typeql::data/match.adoc#_computation[computation], and
xref:typeql::data/match.adoc#_combining_statements[combining statements],
see the xref:typeql::data/match.adoc[] page.

[#_type_patterns]
=== Type patterns

Type patterns are used for schema types.
They can be used only in a `match` and `define` clauses.

.Type patterns
[cols="^.^1,^.^2,^.^2,^.^2"]
|===
| *Pattern name* | *Pattern syntax* | *A `match` clause example* | *A `define` clause example*

| Type
| `<label> type <type>;`
| `$t type person;`
| *N/A* +
_Can't define one type as another one_

| Type or subtype
| `<label> sub <type>;`
| `$t sub subject;`
| `person sub user;`

| Direct subtype
| `<label> sub! <type>;`
| `$t sub! subject;`
| `person sub! user;`

| Role in a relation type
| `<relation> relates <label>;`
| `permission relates $r;`
| `permission relates access;`

| Role player type in a relation
| `<label> plays <relation>:<role>;`
| `$r plays permission:subject;`
| `access plays permission:access;`

| Owner type of an attribute type
| `<label> owns <attr-type>;`
| `$o owns full-name;`
| `person owns full-name;`

| Attribute subtype
| `<label> sub[!] <attribute-type> [, value <value-type>];`
| `$s sub id, value string;`
| `email sub id, value string;`
|===
//#todo Add examples and links to them

In a `match` clause we can't define new types.
Hence, use concept variables instead of `<label>` placeholder.

In a `define` clause all variables are prohibited.
Hence, use type labels instead of `<label>` placeholder.

[#_computation]
=== Computation

[#_arithmetic_operations]
==== Arithmetic operations

The following keywords can be used for arithmetic operations between <<_value_variables,value variables>>,
values of attributes that are stored in concept variables, or constants:

//#todo reimplement the links to examples
// tag::arithmetics[]
1. `()` -- parentheses.
See an xref:typeql::data/advanced.adoc#_using_parentheses[example].
2. `^` -- exponentiation (power).
See an xref:typeql::data/advanced.adoc#_using_exponentiation[example].
3. `*` -- multiplication.
See an xref:typeql::data/advanced.adoc#_using_multiplication[example].
4. `/` -- division.
See an xref:typeql::data/advanced.adoc#_using_division[example].
5. `%` -- https://en.wikipedia.org/wiki/Modulo[modulo,window=_blank]. Returns the remainder of a division.
See an xref:typeql::data/advanced.adoc#_using_modulo[example].
6. `+` -- addition.
See an xref:typeql::data/advanced.adoc#_using_addition[example].
7. `-` -- subtraction.
See an xref:typeql::data/advanced.adoc#_using_subtraction[example].
// end::arithmetics[]

[IMPORTANT]
====
The above list is sorted by the order in which those operations are applied in an expression.
====

.See example
[%collapsible]
====
[,typeql]
----
$f isa file, has size-kb $s;
?mb = $s/1024;
?mb > 1;
----

In the example above, we designed a pattern to find instances of data for `file` type owning `size-kb` attribute
with a value that, after dividing it by 1024 (to get megabytes out of kilobytes), is bigger than 1.
====

[#_built_in_functions]
==== Built-in functions

Built-in functions are usually invoked with adjacent parentheses that contain arguments to apply the function.
Those arguments are separated by a comma as a separator. The following built-in functions are available in TypeDB:

//#todo Reimplement the links to examples
// tag::functions[]
* `min` -- the minimum of the arguments.
See xref:typeql::data/advanced.adoc#_using_minimum_function[example].
* `max` -- the maximum of the arguments.
See xref:typeql::data/advanced.adoc#_using_maximum_function[example].
* `floor` -- the floor function (rounding down).
See xref:typeql::data/advanced.adoc#_using_floor_function[example].
* `ceil` -- the ceiling function (rounding up).
See xref:typeql::data/advanced.adoc#_using_ceiling_function[example].
* `round` -- the default (half-way up) rounding function.
See xref:typeql::data/advanced.adoc#_using_rounding_function[example].
* `abs` -- the modulus (or absolute value) function.
See xref:typeql::data/advanced.adoc#_using_absolute_value_function[example].
// end::functions[]

// tag::combining[]
[#_combining_statements]
== Combining statements

image::pattern-structure.png[Combining statements]
//#todo Fix the image - Types of patterns

By combining statements together, we can express more complex pattern scenarios and their corresponding data.

* *Statement*: A single basic building block, as <<_patterns_overview,explained above>>.
* *Conjunction* (logical `AND`): A set of statements, where to satisfy a match, all statements must be true. +
We use conjunctions *by default* just by separating the partaking statements with semicolons `;`.
* *Disjunction* (logical `OR`): A set of statements, where to satisfy a match, at least one statement must be matched. +
We form disjunctions by enclosing the partaking statements within curly braces `{}` and joining them together with the
keyword `or`.
* *Negation* (logical negation): A statement that explicitly defines conditions that must *not* to be met. +
We form negations by defining the conditions *not* to be met in curly brackets of a `not {};` block.
// end::combining[]

See the <<_complex_example,complex example>> below.

// tag::complex_example[]
[#_complex_example]
=== Complex example

image::example-pattern.png[Complex example]

The pattern is a conjunction of five different pattern types:

. *Conjunction 1* specifies the variables for two `person` instances, their `full-names`, `action`, and `file` that
  has path `README.md`, specifies their types.
. *Disjunction* specifies that the actions of interest are either `modify_file` or `view_file`.
. *Negation 1* specifies that person `$p1` shall not have `full-name` with value of `Masako Holley`.
. *Negation 2* specifies that person `$p2` shall not have `full-name` with value of `Masako Holley`.
. *Conjunction 2* specifies that the `file` has `access` with the `action` that we specified earlier,
  and both instances of the `person` to have the `permission` to the specified `access`.

In short, the above example finds pairs of people who both have permission to access the same file
with a path of `README.md`. The pattern additionally specifies the access to be either `modify_file` or `view_file`,
and neither people to have the full-name `Masako Holley`.
// end::complex_example[]
// end::patterns_body[]
