= Update query
:Summary: Updating data in a TypeDB database.
:keywords: typeql, typedb, query, update, replace, insert, delete
:pageTitle: Update query

An Update query is used to replace data in a TypeDB database.
This query can be viewed as a `match-delete-insert` query,
as it removes and then adds data based on the `match`, `delete`, and `insert` patterns.

Update queries can be used only in write transactions.

== Behaviour

An Update query deletes concepts and then inserts new concepts to a database.

After matching existing data with a `match` clause,
use a `delete` clause with another TypeQL pattern to specify exact data to delete,
finally, use an `insert` clause with yet another pattern to insert new data instead.

//A `match` clause uses a pattern to match existing data to be changed.
//A `delete` clause uses a pattern to specify data that should be removed.
//A `insert` clause uses a pattern to specify data that should be inserted.

Both `delete` and `insert` clauses are executed once per result of a preceding `match` clause.
In particular, if there is no match in a database for a `match` clause of an Update query,
then there will be no deletions and no insertions.

An Update query returns a lazy Stream/Iterator of ConceptMap with the inserted data.
Inserted data must not violate a schema of a database.

`delete` and `insert` patterns must have at least one concept variable from a `match` clause of the same query.

== Syntax

An Update query consists of a
<<_match_clause,match>>,
<<_delete_clause,delete>>, and
<<_insert_clause,insert>> clauses.

Updates queries are written in TypeQL with the following syntax:

[,typeql]
----
match <pattern>
delete <pattern>
insert <pattern>
----

Both `delete` and `insert` clause patterns use variables from a preceding `match` clause pattern.

[#_match_clause]
== Match clause

A `match` clause is mandatory in an Update query.
You can use a declarative and composable TypeQL pattern in a `match` clause and TypeDB will find data that matches
specified pattern.

For more information on a `match` clause, see the xref:data/match.adoc[] page.

For more information on patterns used in a `match` clause, see the
xref:data/match.adoc#_patterns_overview[Patterns overview] section.

[#_delete_clause]
== Delete clause

include::typeql::data/delete.adoc[tags=delete_clause]

[#_insert_clause]
== Insert clause

include::typeql::data/insert.adoc[tags=insert_clause]

[#_examples]
== Examples

=== Replacing ownership

In many cases, the desired effect is to change the value of an owned attribute.
We can't change the value of an attribute as attributes are immutable, but we can change the owned attribute.
To update an attribute owned by an entity, its ownership must first be removed.
Then, the entity can be assigned ownership of an attribute with a different value.
It can be an existing attribute or a new one.

.Replacing ownership
[,typeql]
----
match
$p isa person,
    has full-name "Masako Holley",
    has email $email;
delete
$p has $email;
insert
$p has email "m.holley@vaticle.com";
----

The above query does the following:

. Matches all `person` entities (`$p`) that have a `full-name` attribute with a value of `Masako Holley`.
. Deletes from `$p` ownership of its current `email` attribute.
. Makes `$p` the owner of the `email` attribute with the value of `m.holley@vaticle.com`.

If there is an existing `email` attribute with the value of `m.holley@vaticle.com`,
the matching `person` entities will now own it.
Otherwise, a new attribute will be created implicitly and owned by the matching `person` entities.

If there are more than one `$email` found for `Masako Holley` person,
than there will be more than one result for the `match` clause.
Both `delete` and `insert` clauses will be executed exactly once for every matched result (for every `$email`).
Inserting multiple ownerships of the same attribute for the same owner
produces the same result as inserting one.

[NOTE]
====
An `email` attribute with the previous value of `masako.holley@vaticle.com` will still exist,
but it will no longer be owned by the matching `person` entities.
====

=== Replacing attributes

There may be times when the desired effect is to change the value of multiple owned attributes, all of the same type.
This is done by removing them and inserting the ownership of a new/different attribute.

[,typeql]
----
match
  $p isa person, has full-name $n;
  $n contains "inappropriate word";
delete
  $n isa full-name;
insert
  $p has full-name "deleted";
----

The above query:

. Finds all `person` entities (`$p`) with at least one owned `full-name` attribute (`$n`).
. Filters `$n` (and consequently `$p`) to only those that contain the string `inappropriate word`.
. Removes these `full-name` attributes that contain the string from the database.
. Makes `$p` (all entities of person that had `full-names` that contained the string) the owners of a `full-name`
attribute with a value of `deleted`.

If a similar query has been run before, there may be an existing attribute with a value of `deleted`, which the matching
`person` entities will now own. If not, a new `full-name` attribute will be inserted, and the matching `person` entities
will own it.

[NOTE]
====
After running the above query, there will be a single `full-name` attribute with a value of `deleted`, which is owned by
the matching entities, and any `full-name` attributes which had contained the string `inappropriate word` will no
longer exist.
====

=== Updating a relation's role player

To replace a role player, we combine the steps for extending the relation with steps for deleting a role player:

[,typeql]
----
match
$p isa person, has full-name "Pearle Goodman";
$a_write isa action, has name "modify_file";
$a_read isa action, has name "view_file";
$ac_write (object: $o, action: $a_write) isa access;
$ac_read (object: $o, action: $a_read) isa access;
$pe (subject: $p, access: $ac_write) isa permission;
delete
$pe (access: $ac_write);
insert
$pe (access: $ac_read);
----

The above query does the following:

. Finds the `person` entity (`$p`) with the `full-name` of `Pearle Goodman`.
. Finds the `action` entity (`$a_write`) with the `name` of `modify_file`).
. Finds the `action` entity (`$a_read`)  with the `name` of `read_file`).
. Finds all `access` relations (`$ac_write`) that relate any `object` (as `object`) to `$a_write` (as `action`).
. Finds all `access` relations (`$ac_read`) that relate any `object` (as `object`) to `$a_read` (as `action`).
. Finds all permissions (`$pe`) that relate `$p` (as `subject`) to `$ac_write` (as `access`).
. Removes all write accesses (`$ac_write`) as a player of the `access` role in matching permission relations
(`$pe`).
. Adds all read accesses (`$ac_read`) as a player of the `access` role in matching permission relations (`$pe`).

In short, all of Pearle Goodman's permissions with write access will become permissions with read access.

[NOTE]
====
After running the above query, all matched `access` relations `$ac_write` with `$a_write` as `action` still
exist but no longer play a role in the matched `permission` relations.
====
