[#_types]
= Types
:Summary: Defining types with TypeQL.
:keywords: typeql, schema, type, inheritance
:longTailKeywords: typeql schema, typeql type hierarchy, typeql data model
:pageTitle: Define types
:toc: macro
:toclevels: 5
:experimental:

// tag::types_basics[]
A type represents a set of constraints on the interpretation of data.

A type for a data instance is like a class for an object in OOP.

A definition of a type in a schema of a database sets:

* type hierarchy -- every user-defined type has only one parent or supertype.
* constraints -- what a type can do: what role to play, what attributes it can own, what value type it has
(attribute types only), and what roles it relates (relation types only).

A type can be addressed by its label (name). A type label is unique in a schema of a database.

We can define a new type only as a subtype of an existing one.

A new empty database has a set of built-in types. These built-in types are called root types because all user-defined
types will be subtypes (direct or non-direct) of those root types.

.Root (built-in) types
[cols="^.^1, ^.^3, ^.^4",options="header"]
|===
| Root type label | A subtype of the root type | An instance of data of a subtype

| `entity`
| Entity type
| Instance of entity type

| `relation`
| Relation type
| Instance of relation type

| `attribute`
| Attribute type
| Instance of attribute type
|===

[IMPORTANT]
====
All root types are <<_abstract_types,abstract>> types.

That's why when we say *entity type*, we usually mean a subtype of the `entity` root type.
In the same way, we can address *relation type* or *attribute type* instead of mentioning
subtypes of the root types.
====
// end::types_basics[]

[NOTE]
====
To avoid ambiguity when using type labels, we should try to provide context or specify what exactly
we mean:

- the type and all its subtypes (the default variant),
- the exact type, without any of its subtypes,
- or instances of data of this particular type and instances of data of all its subtypes.
====

[#_inheritance]
== Inheritance
// tag::inheritance_basics[]

A type can subtype another type. As a result, the subtype inherits all the attributes owned and roles played by its
supertype.

[NOTE]
====
Roles can be inherited and even overridden as a part of relation inheritance.
====

Type can only have a single supertype.

Types can be subtypes of other subtypes, resulting in a type hierarchy.

.Simple example
====
For example, `business-unit` subtypes `user-group`, which subtypes `subject`, which subtypes `entity` root type.
Also, `person` subtypes `user`, that subtypes `subject`:

* entity
** subject
*** user group
**** business unit
*** user
**** person

In TypeQL we can define these types with the following query:

[,typeql]
----
define

subject sub entity;
user-group sub subject;
business-unit sub user-group;
user sub subject;
person sub user;
----
====

There is a strict hierarchy of types, so the whole typing system of a TypeDB database can always be represented
by three independent trees with one of the root types at the top of each tree.

.Hierarchy trees example
====
For example, a schema with the following types:

* entity
** person
** vehicle
*** car
*** motorcycle
*** bicycle

* relation
** owning
** using
*** driving
*** traveling

* attribute
** model
** name
*** full-name
*** nickname

can be visualized as following type hierarchy:

image::root-types-trees.png[]
====
// end::inheritance_basics[]

[#_abstract_types]
== Abstract types
// tag::abstract_basics[]

An abstract type can't be instantiated (we can't insert an instance of data of this type). All we can do with an
abstract type is to subtype it.

All root types are abstract types.

The opposite of an abstract type is a concrete type.

All user-defined types are concrete types by default.
// end::abstract_basics[]

[#_thing_type]
== Thing type
// tag::thing_type_basics[]

An internal type called `thing` can be used to address all types (both built-in and user-defined) or instances of all
types (effectively — all data).

All types are subtypes of the `thing`, including the root types.

image::thing-era-role-rule.png[Types hierarchy]

// #todo Redraw the diagram. Without the Thing. Consider using PlantUML

include::typedb::partial$thing-warning.adoc[]
// end::thing_type_basics[]

[#_entity_types]
== Entity types
// tag::entity_type_basics[]

*Entity types* (or subtypes of the `entity` root type) represent the classification of independent objects in the
data model of our business domain.

Instance of data of an entity type represents a standalone object that exists in our data model independently.

Instance of an entity type doesn't have a value.
It is usually addressed by its ownership over attribute instances and/or roles played in relation instances.

An object modeled with an entity type might practically require other entities to exist, such as a car that cannot
exist without its parts, but can be conceptualized without reference to those other entities: a car can be imagined
without considering its parts.

// end::entity_type_basics[]

.See example
[%collapsible]
====
Given the schema:

[,typeql]
----
define

name sub attribute, value string;

person sub entity,
    owns name,
    plays marriage:spouse;

marriage sub relation,
    relates spouse;
----

An instance of the `person` type can be inserted in a database:

* without owning any instances of the `name` attribute type, nor playing any roles,
* owning exactly one instance of the `name` attribute type with some value and playing a role of a spouse in a marriage
  relation,
* owning multiple names and/or playing the role `spouse` in multiple instances of the `marriage` relation type.
====
//#todo Improve the example

To define a new entity type, we need to set its label and what type it's a subtype of.

To set a property of an entity (like a name of a person), we need to define ownership by this entity of an instance
of an `attribute` type with the required value.

To define a relationship between an entity and some other user-defined types, we need to define a relation with roles
and the ability of the involved types to play those roles.

.Entity types and instances example
[%collapsible]
====
For example, there could be entity types like `company` and `person`.

Given the `company` entity type defined in a database schema, we can insert instances of data of this type in such
a database. Every instance of the `company` type inserted into the database will represent a company, that can be
addressed by whatever attributes it has (e.g., name, registration number), or by roles played in relations (e.g.,
`employer` for the particular instance of `person` entity type in an `employment` relation type).

image::instances-example.png[]

On the above image two instances of `company` type are called `Company #1` and `Company #2`, while in real life
scenario in a TypeDB database there is almost no way to differentiate between those two instances if they have no
attributes and do not participate in any relations. The only information we can get from existence of two instances
is that there are two distinct objects. But its really hard to tell which one is which without any additional
related data inserted.
====

For more information on how to define an `entity` type, see the
xref:schema/define.adoc#_define_entity_types[Define entity types] section on the
xref:schema/define.adoc[] page.

== Relation types
// tag::relation_type_basics[]

Relation types (or subtypes of the `relation` root type) represent relationships between types.
Relation types have roles.

Other types can play roles in relations if it’s mentioned in their definition. An instance of another type
can be a role player for a role in the instance of a relation.

An instance of a relation can be uniquely addressed by a combination of its type, owned attributes, and role players.

A `relation` type must specify at least one role. A relation cannot be conceptualized without at least some of its
role players.

// end::relation_type_basics[]

// tag::relation_type_examples[]

.See the group-membership example
[%collapsible]
====
For example, given the schema:

[,typeql]
----
define

group-membership sub relation,
    relates user-group,
    relates group-member;

user-group sub entity
    plays group-membership:user-group;

subject sub entity,
    plays group-membership:group-member;
user sub subject;
----

`group-membership` is a `relation` type that defines `user-group` and `group-member` roles.
The `user-group` role is to be played by a `user-group` entity type whereas the `group-member` role is to be played by
a `subject` type and all its subtypes entities.
====
// end::relation_type_examples[]

=== Roles

Roles are special internal types used by relations. We can't create an instance of a role in a database.
But we can set an instance of another type (role player) to play a role in a particular instance of a relation type.

Roles allow a schema to enforce logical constraints on types of role players.

.See the example of a role player's type constraint
[%collapsible]
====
For example, given the schema below, a `file` type entity can't play any role in a `group-membership` relation,
and a `user` type entity can play the `group-member` role of a `group-membership` relation because it inherits it
from the `subject` type.

[,typeql]
----
define

group-membership sub relation,
    relates user-group,
    relates group-member;

user-group sub entity
    plays group-membership:user-group;

subject sub entity,
    plays group-membership:group-member;
user sub subject;

file sub entity;
----
====

==== Abstract roles

[IMPORTANT]
====
Since TypeDB v.`2.22.0`, all roles are concrete, even in <<_abstract_types,abstract>> relations.
====

.See the example of a concrete role in abstract type
[%collapsible]
====
Given the following schema:

[,typeql]
----
define

membership sub relation,
    abstract,
    relates member;

group-membership sub membership;
----

The concrete relation type `group-membership` inherits the `member` role from the abstract relation
type `membership`.

Before version `2.22.0` of TypeDB, roles of abstract relations are also abstract.
It would make the role `member` abstract.
//Even if it is inherited by a concrete relation, an abstract role continues to be abstract.
//We can't use an abstract role to insert an instance of a relation type.
We have to xref:schema/define.adoc#_overrides_a_role[override]
an abstract role with a new concrete role to use it for data.

////
[,typeql]
----
define

group-membership sub membership,
    relates group-member as member;
----

Then we can insert an instance of the `group-membership` type with the new role:

[,typeql]
----
insert
(group-member: $x) isa group-membership;
----
////

Since version `2.22.0` of TypeDB, all roles are concrete.
We can use a role inherited from an abstract relation directly without the need to override it with a new role:

[,typeql]
----
insert
(member: $x) isa group-membership;
----
====

[WARNING]
====
Databases created in versions of TypeDB prior to `2.22.0` will continue to use abstract roles for abstract relation,
defined in schema prior to update for version `2.22.0` or newer.

The best way to switch to the new behavior is to install the TypeDB v.`2.22.0+`, create a new database,
define the same schema, and load the same data into it.

.See the alternative way to manually upgrade database schema
[%collapsible]
=====
The alternative way to migrate to the new behaviour is to reset (unset and set) the abstractness of each abstract
relation type via the Driver API methods:

.Abstract methods
[cols="^.^1,^.^2,^.^2,^.^2",caption="",options="header"]
|===
| Method | TypeDB Java Driver | TypeDB Python Driver | TypeDB Node.js Driver

| Is `abstract`
| xref:clients:ROOT:java/java-api-ref.adoc#_check_if_type_is_abstract_local[isAbstract();]
| xref:clients:ROOT:python/python-api-ref.adoc#_check_if_type_is_abstract_local[is_abstract()]
| xref:clients:ROOT:node-js/node-js-api-ref.adoc#_check_if_type_is_abstract_local[abstract;]

| Set `abstract`
| xref:clients:ROOT:java/java-api-ref.adoc#_set_abstract[setAbstract();]
| xref:clients:ROOT:python/python-api-ref.adoc#_set_abstract[set_abstract()]
| xref:clients:ROOT:node-js/node-js-api-ref.adoc#_set_abstract[setAbstract();]

| Unset `abstract`
| xref:clients:ROOT:java/java-api-ref.adoc#_unset_abstract[unsetAbstract();]
| xref:clients:ROOT:python/python-api-ref.adoc#_unset_abstract[unset_abstract()]
| xref:clients:ROOT:node-js/node-js-api-ref.adoc#_unset_abstract[unsetAbstract();]
|===

.Pseudocode example
[,python]
----
for rel_type in relation_types:
  if rel_type.is_abstract():
    rel_type.unset_abstract()
    rel_type.set_abstract()
commit()
----
=====
====

////
.See example
[%collapsible]
====
Given the schema:

[,typeql]
----
define

name sub attribute, value string;

person sub entity,
  owns name,
  playes spouce:marriage;

marriage sub relation,
  relates spouse;
----

An instance of a `marriage` relation type can be addressed by the instances of the `person` entity type that play the
role of spouses.

It is impossible to imagine a marriage without considering its spouses.
====
//#todo Improve the example
////

For more
information on how to define a `relation` subtype, see the
xref:schema/define.adoc#_define_relation_types[Define relation types] section on the
xref:schema/define.adoc[] page.

[#_attribute_types]
== Attribute types
// tag::attribute_type_basics[]

Attribute types (or subtypes of the `attribute` root type) represent properties that other types can own.

Attribute types have a value type, and instances of attribute types have a value.
This value is fixed and unique for every given instance of the attribute type.

Other types can own an attribute type.
That means that instances of these other types can own an instance of this attribute type.
This usually means that an object in our domain has a property with the matching value.

An instance of an attribute type can be uniquely addressed by its type and value.

There can't be a second instance of the same type with the same value.

Multiple types can own the same attribute type -- and different instances of the same type or different types can
share ownership of the same attribute instance.

// end::attribute_type_basics[]

For more information on the types of values, attributes can have: see the
xref:schema/define.adoc#_value_types[list of value types] on the
xref:schema/define.adoc[] page.

// tag::attribute_type_example[]

.See example
[%collapsible]
====
Given the schema:

[,typeql]
----
define

name sub attribute, value string;

person sub entity,
    owns name;
----

An instance of an attribute type `name` with a value "Bob" can be owned by:

* no one (no instance of the `person` type owns the instance of the `name` type with value "Bob"),
* one particular person (there is one person with such a name),
* or multiple people (there are multiple people with the name `Bob`. All of the `pesron` type instances have ownership of
  the same instance of the `name` type with the value "Bob").
====
// end::attribute_type_example[]

// tag::attribute_type_own_depr[]
[WARNING]
====
The feature of an attribute type owning another attribute type will be deprecated in one of the upcoming versions and
deleted in TypeDB version 3.0.
====
// end::attribute_type_own_depr[]

For more information on how to define an `attribute` subtype, see the
xref:schema/define.adoc#_define_attribute_types[Define attribute types] section on the
xref:schema/define.adoc[] page.
