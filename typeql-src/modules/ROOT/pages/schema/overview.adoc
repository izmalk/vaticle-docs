= Schema
:Summary: TypeQL schema queries section overview.
:keywords: typeql, typedb, schema, types, rules, overview
:pageTitle: Schema

A schema is like a blueprint of a database that contains all user-defined <<_types,types>> and rules used in a database.

[#_types]
== Types
// tag::types_basics[]
Types in a schema are modeled with the use of the PERA model.



All queries are validated with the TypeQL syntax and a type system of a schema.
Every piece of data inserted in a TypeDB database as an instance of a type.


A type represents a set of constraints on the interpretation of data.

A type for a data instance is like a class for an object in OOP.

A definition of a type in a schema of a database sets:

* type hierarchy -- every user-defined type has only one parent or supertype.
* constraints -- what a type can do: what role to play, what attributes it can own, what value type it has
(attribute types only), and what roles it relates (relation types only).

A type can be addressed by its label (name). A type label is unique in a schema of a database.

We can define a new type only as a subtype of an existing one.

A new empty database has a set of built-in types. These built-in types are called root types because all user-defined
types will be subtypes (direct or non-direct) of those root types.

.Root (built-in) types
[cols="^.^1, ^.^3, ^.^4",options="header"]
|===
| Root type label | A subtype of the root type | An instance of data of a subtype

| `entity`
| Entity type
| Instance of entity type

| `relation`
| Relation type
| Instance of relation type

| `attribute`
| Attribute type
| Instance of attribute type
|===

[IMPORTANT]
====
All root types are <<_abstract_types,abstract>> types.

That's why when we say *entity type*, we usually mean a subtype of the `entity` root type.
In the same way, we can address *relation type* or *attribute type* instead of mentioning
subtypes of the root types.
====
// end::types_basics[]

[NOTE]
====
To avoid ambiguity when using type labels, we should try to provide context or specify what exactly
we mean:

- the type and all its subtypes (the default variant),
- the exact type, without any of its subtypes,
- or instances of data of this particular type and instances of data of all its subtypes.
====



TypeQL has only two types of schema manipulation queries: Define and Undefine.
Both Define and Undefine queries can be used only in a
xref:typedb::connecting/overview.adoc#_sessions[schema session] and
xref:typedb::connecting/overview.adoc#_transactions[write transaction].
For more information on the limitations of a schema session, see the
xref:typedb::basics/acid.adoc#_schema_integrity[Schema integrity enforcement].

For more information about data modeling with TypeQL and xref:typedb::basics/data-model.adoc[PERA] model, see the
xref:typeql::fundamentals.adoc[] page.

== Define query

[cols-2]
--
.xref:typeql::schema/define-types.adoc[Define types]
[.clickable]
****
Use a Define query to add new or modify existing types.
****

.xref:typeql::schema/define-rules.adoc[Define rules]
[.clickable]
****
Use a Define query to add new or replace existing rules.
****
--

== Undefine query

[cols-1]
--
.xref:typeql::schema/undefine.adoc[Undefine]
[.clickable]
****
This query type can be used to delete types and rules definitions from a schema.
****
--