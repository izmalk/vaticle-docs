= Get query
:Summary: Reading data from a TypeDB database with a Get query.
:keywords: typeql, query, get, read, retrieve, concepts
:pageTitle: Get query
:page-aliases: typeql::data/get.adoc

A Get query retrieves concepts as stateful objects from a TypeDB database that you can further process with the
xref:drivers::overview.adoc#_driver_api[driver API] methods.
For example, see the xref:manual::objects/data.adoc[data objects] and
xref:manual::objects/schema.adoc[schema objects] pages.

For a practical guide on how to send a Get query to TypeDB,
see the xref:manual::reading/get.adoc[] page of TypeDB Manual.
Get queries can use rule-based xref:manual::reading/infer.adoc[inference].

== Syntax

// tag::syntax[]
A Get query consists of a
<<_match_clause,match>> and a
<<_get_clause,get>> clauses:

[,typeql]
----
match <pattern>
get [<variable> [, <variable>]];
----

A Get query can include multiple xref:typeql::modifiers/overview.adoc[modifiers] at the end.
// end::syntax[]

[#_behavior]
== Behavior

A Get query retrieves xref:typeql::concepts/overview.adoc[concepts] from a database.

A `match` clause is used to match data by a pattern, while a `get` clause is used to filter the returned variables.

A Get query projects concepts matched from a database to language-specific programmatic stateful objects
that can be used via driver API methods.
The output of a Get query is a lazy stream/iterator of ConceptMap objects, unless it's used with
xref:typeql::modifiers/aggregation.adoc[aggregation], xref:typeql::modifiers/grouping.adoc[grouping], or both.
See the table below for a complete list of response formats:

[#_table_output_types]
[cols="^.^1,^.^4,^.^4"]
|===
| *#* | *Query* | *Response format*

| 1
| Get query
| Stream/Iterator of *ConceptMap*

| 2
| Get query with aggregation
| *Promise* of *Value*

| 3
| Get query with grouping
| Stream/Iterator of *ConceptMapGroup*

| 4
| Get query with grouping and aggregation
| Stream/Iterator of *ValueGroup*
|===

[#_match_clause]
== Match clause

A `match` clause in a Get query matches existing concepts in a database to retrieve them as objects.
You can use a declarative and composable TypeQL pattern in a `match` clause and TypeDB will find data that matches
specified pattern.

A `match` clause is mandatory in a Get query.

For more information on patterns and statements used in a `match` clause, see the
xref:typeql::patterns/overview.adoc[Patterns] and xref:typeql::statements/overview.adoc[Statements] sections.

[#_get_clause]
== Get clause

A `get` clause is used in a Get query to select variables
(xref:typeql::concepts/concept-variables.adoc[concept variables] and
xref:typeql::values/value-variables.adoc[value variables])
to include in every <<_conceptmap,ConceptMap>> of the output.
An empty `get` clause (`get;`) returns all variables, used in the preceding `match` clause.

Filtering variables with a `get` clause can <<_number_of_results,change>> the number of results.
Applying xref:typeql::modifiers/sorting.adoc[] or xref:typeql::modifiers/pagination.adoc[] with a variable
not listed in a `get` clause can effectively add such a variable to the `get` clause.

[#_conceptmap]
=== ConceptMap

Iterate on a non-empty response from a Get query to get a ConceptMap object.
There is exactly one ConceptMap returned for every matched solution retrieved by a Get query.

A ConceptMap object maps a query variable to a Concept object.
To retrieve a concept object from a ConceptMap, use the driver API `ConceptMap.get(variable)` method,
that takes input of variable's label.
Further processing of a Concept is done via methods of the driver API.
//#todo Add an example in all 4 languages (with tabs) - from sending a query to getting a value out of an attribute

[#_number_of_results]
== Number of results

include::typeql::partial$iam-database-links.adoc[]

A Get query can return fewer results, than answers matched by its `match` clause.
That is due to a natural deduplication of results.
See an example below.

.Example of a get clause reducing the number of results
[,typeql]
----
match
$p isa person, has full-name $n;
get $n;
----

In the above example `match` clause matches all `person` type instances that own a `name` attribute.
The `get` clause then returns only the attributes.

What happens if two or more people have the same attribute?
In a TypeDB database, attributes are immutable and unique.
So multiple entities of the `person` type own the same attribute (instance of the `name` attribute type).
The `match` clause finds all pairs of a person and its owned attribute.
But `get` clause filters to return only the attributes.
Since more than one person owns the very same attribute, it is matched multiple times as a pair person + full name.
But after filtering, the attribute is returned only once.

//For more examples of filtering matched results, see the <<_results_example_1>> and <<_results_example_2>>.

[#_simple_example]
== Usage of a Get query

include::typeql::partial$iam-database-links.adoc[]

A simple Get query example:

.Simple example
[,typeql]
----
match
$p isa person,
    has full-name "Kevin Morrison",
    has email $e;
get $e;
----

The above query uses only two variables: `$p` and `$e`.
The `full-name` attribute is not bound to a variable in this query.

The example above matches person (`$p`) with ownership of the `full-name` attribute with a value of `Kevin Morrison` and
the `email` attribute (`$e`) with any value.
The `get` clause then filters the results to retrieve only the `email` (`$e`) attributes.

The response is a stream/iterator of ConceptMap.
Every ConceptMap bounds the variable `$e` to an attribute of the `email` type, that matches the pattern.

[#_complex_get_query_example]
== Usage of a Get query with modifiers

include::typeql::partial$iam-database-links.adoc[]

For the next example, let's try a bit more complex pattern and some modifiers:

.Complex Get query example
[,typeql]
----
match
$pe ($x, $y) isa permission;
$x isa person, has full-name $x-n;
$x-n contains "Kevin";
$y (object: $o, action: $act) isa access;
$act has name $act-n;
$o has path $o-fp;
get $x-n, $act-n, $o-fp;
sort $o-fp;
group $o-fp;
count;
----

The example above uses a `match` clause to find data that matches the following conditions:

. `permission` relation (`$pe`) of `$x` and `$y` variables.
. `$x` is `person` entity that has an attribute `$x-n` with the type `full-name`.
. The value of `$x-n` should contain the substring `Kevin`.
. The `$y` is a `access` type relation of `$o` a role of object and `$act` as action.
. `$act` has an attribute `$act-n` with the type `name`.
. `$o` has an attribute `$o-fp` with the value `path`.

The `get` clause then filters the matched answers from the `match` clause to get only the concepts for the
`$x-n`, `$act-n`, `$o-fp` variables.

The results are sorted and grouped by the `$o-fp` and aggregated with the `count` function.

The response is the number of results for every `$o-fp`: number of pairs `$x-n` and `$act-n`.

[#_results_example_1]
== Permutations

include::typeql::partial$iam-database-links.adoc[]

If there are multiple variables returned in every result,
then results of a query include all permutations of answers.

To illustrate that behavior, let's
see what happens if we have *three* `person` entities
and *ten* `file` entities in a database with the IAM schema and
send the following get query:

//#todo Replace the example to exclude the disjoint match pattern
//it can be a relation like $f($x,$y) isa friendship
//or an attribute ownership, like $x has $y
.Permutations example
[,typeql]
----
match
$x isa person;
$f isa file;
get $x, $f;
----

How many results are we expecting to retrieve from a database?

[NOTE]
====
Spoiler: **13** is the wrong answer here.
====

As the example above doesn't have any xref:typeql::modifiers/overview.adoc[modifiers]
(including aggregation and grouping) the number of results is equal to the number of matched solutions
for the pattern in the `match` clause.
Each solution consists of one `person` entity and one `file` entity.
There are only `3 * 10 = 30` possible combinations of `person` and `file` entities, so we will get *30* results.

For more explanation and examples, see the
xref:learn::7-understanding-query-patterns/7.6-solution-set-semantics.adoc[] page in the TypeDB Learning course.

////
[#_results_example_2]
=== Variables filtering

include::typeql::partial$iam-database-links.adoc[]

For the following example, consider the following database schema:

[,typeql]
----
define

name sub attribute, value string;
age sub attribute, value long;
certified-fortune-teller sub attribute, value boolean;

person sub entity,
    owns name,
    owns age,
    owns certified-fortune-teller;
----

Let's explore the following query:

[,typeql]
----
match
$p isa person,
    has name `Bob`,
    has age 31,
    has certified-fortune-teller $cft;
get $p, $cft;
----

The above query will find every `person` entity that has ownership over the instance of the attribute type `name` with
the value of `Bob`, ownership of the `age` with the value of `31`, and the ownership of the `certified-fortune-teller`
attribute with any value.

With the `get` clause, we filter the results to get the `person` instances and the corresponding
`certified-fortune-teller` attribute (represented by the `$cft` variable in the pattern) for every matched result
in a database.

[#_explanation_of_filter]
_Why not filter for just the `$cft` variable instead?_

That can drastically alter the returned results as the returned results are deduplicated by design. See the
<<_number_of_results>> section above for more information on the number of results for a Get query.

For example, let's say we have ten people with the name `Bob` and age `31` in our database.
Five of them have `certified-fortune-teller` with the value `false`, one has it as `true`,
and the rest don't have an ownership of the attribute.

[#_answers_example2_dataset]
.See how to load such a dataset into a database
[%collapsible]
====
In xref:manual::studio.adoc[TypeDB Studio], we can paste the following TypeQL in the text editor
and send all the queries by a single click in a data/write mode.
Make sure to commit the changes.

[,typeql]
----
# These are the 5 instances of people with name Bob, age 31 and not cretified fortune tellers
insert $p isa person, has name "Bob", has age 31, has certified-fortune-teller false;
insert $p isa person, has name "Bob", has age 31, has certified-fortune-teller false;
insert $p isa person, has name "Bob", has age 31, has certified-fortune-teller false;
insert $p isa person, has name "Bob", has age 31, has certified-fortune-teller false;
insert $p isa person, has name "Bob", has name "Bobby", has age 31, has certified-fortune-teller false;

# This is the one and only instance of a person with name Bob, age 31 and a cretified fortune teller
insert $p isa person, has name "Bob", has age 31, has certified-fortune-teller true;

# These are the 4 instances of people with name Bob, age 31. No ownership of the boolean attribute
insert $p isa person, has name "Bob", has age 31;
insert $p isa person, has name "Bob", has name "Robert Jr.", has age 31;
insert $p isa person, has name "Bob", has age 31;
insert $p isa person, has name "Bob", has age 31;

# These are some random people, that doesn't meet pattern (Name: Bob and Age: 31)
insert $p isa person, has name "Bob", has age 20;
insert $p isa person, has name "Alex", has age 78, has certified-fortune-teller false;
insert $p isa person, has name "Alice", has age 31, has certified-fortune-teller true;
insert $p isa person;
----

To insert this dataset with any xref:drivers::overview.adoc[other] client --
make sure to send every line, except from comments, as a separate insert query.

For more information on an Insert query, see the xref:typeql::queries/insert.adoc[] page.
====

Those Bobs that don't have the attribute ownership won't be matched by the `match` clause at all.
So we expect to get *six* results from the original Get query:
five `person` instances owning the attribute with value `false` and one with `true`.

If we remove the `$p` variable and use `get $cft;` clause instead,
we'll get only two results in response because we will only get
`certified-fortune-teller` instances, and there are only two of those: an instance with the `true` value and another
instance of the same type with the `false` value.

The initial five instances of `person` type all have ownership over the
same attribute of the `certified-fortune-teller` attribute type
with the value `false`.

To get all the results, we add the `person` type instances to the results because those are unique.
Even if some of them might have the exact same set of owned attributes, instances of the `person` type are
different instances nonetheless.

To try the get queries in that example, we need to load the <<_results_example_2,schema>> and
the <<_answers_example2_dataset,dataset>> provided above into a TypeDB database first.
////

== Learn more

[cols-2]
--
.xref:learn::7-understanding-query-patterns/7-understanding-query-patterns.adoc[]
[.clickable]
****
Learn more about query patterns in the TypeDB Learning course.
****

.xref:manual::reading/get.adoc[]
[.clickable]
****
See how to send a Get query to TypeDB.
****

.xref:manual::objects/schema.adoc[]
[.clickable]
****
See how to manipulate Schema stateful objects with driver API.
****

.xref:manual::objects/data.adoc[]
[.clickable]
****
See how to manipulate Data stateful objects with driver API.
****
--
