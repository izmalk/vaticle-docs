= isa

The `isa` keyword is used in TypeQL statements to specify a type or supertype of a data instance.
For specifying only a direct type of a data instance, see the xref:typeql::statements/isa-em.adoc[] statement instead.

== Syntax

The syntax of a simple statement with the `isa` keyword:

.Syntax
[,typeql]
----
<data-instance> isa <type>
----

Where `data-instance` can be a concept variable representing a data instance, a literal value representing an attribute,
or both; `type` can be a type label or a concept variable representing a type.

== Usage

TypeQL statements with the `isa` keyword can be used in data queries to set a type constraint for data instances.

When used in a `match` or `delete` clause pattern,
the `isa` keyword enables type inference to use all subtypes of the provided type.

When used in an `insert` clause pattern, the `isa` keyword doesn't use subtypes and
its behavior is the same as the xref:typeql::statements/isa-em.adoc[isa!] keyword.

== Examples

To run the examples below, you can use a database with the following schema and data loaded:

* link:https://github.com/vaticle/typedb-docs/blob/master/drivers-src/modules/ROOT/partials/tutorials/iam-schema.tql[iam-schema.tql]
-- A TypeQL Define query for the sample IAM schema.
* link:https://github.com/vaticle/typedb-docs/blob/master/drivers-src/modules/ROOT/partials/tutorials/iam-data-single-query.tql[iam-data-single-query.tql]
-- A TypeQL Insert query for the sample IAM data.

// * xref:drivers::partial$tutorials/iam-schema.tql[iam-schema.tql] -- TypeQL Define query for the sample IAM schema
// * xref:drivers::partial$tutorials/iam-schema.tql[iam-data-single-query.tql] -- TypeQL Insert query for the sample IAM data

=== Simple example

To match all data instances of the `person` type (or any of its subtypes):

.isa statement example
[,typeql]
----
match
$p isa person;
fetch $p: full-name;
----

.Output example
[,json]
----
{
    "p": {
        "full-name": [ { "value": "Kevin Morrison", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } } ],
        "type": { "label": "person", "root": "entity" }
    }
}
{
    "p": {
        "full-name": [ { "value": "Masako Holley", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } } ],
        "type": { "label": "person", "root": "entity" }
    }
}
{
    "p": {
        "full-name": [ { "value": "Pearle Goodman", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } } ],
        "type": { "label": "person", "root": "entity" }
    }
}
----

=== Complex example

We can use the `isa` keyword in a complex statement with other keywords, for example,
xref:typeql::statements/has.adoc[has].

Let's see how to match every data instance of the `person` type that have ownership of at least one attribute of the
`full-name` type.

.Complex example
[,typeql]
----
match
$p isa person, has full-name $f;
fetch $f;
----

.Output example
[,json]
----
{ "f": { "value": "Kevin Morrison", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } } }
{ "f": { "value": "Masako Holley", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } } }
{ "f": { "value": "Pearle Goodman", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } } }
----

=== Type variablization example

The `isa` keyword can be used with a concept-variable instead of a type label to the right.
That sets a constraint on the concept variable to be of any valid, according to the rest of the pattern, type.

.Type variablization example
[,typeql]
----
match
$p isa $type, has full-name $f;
fetch $type;
----

.Output example
[,json]
----
{ "type": { "label": "entity", "root": "entity" } }
{ "type": { "label": "subject", "root": "entity" } }
{ "type": { "label": "user", "root": "entity" } }
{ "type": { "label": "person", "root": "entity" } }
{ "type": { "label": "thing", "root": "thing" } }
----

In the above example, we fetch the `$type` concept variable that represents not a data instance, but the type of `$p`.
As a result of this query, we get all the types of all matched `$p`, as well as all their supertypes.
To get only direct types, and no supertypes, use the xref:typeql::statements/isa-em.adoc[isa!] keyword instead of `isa`.

== Learn more

[cols-2]
--
.xref:typeql::statements/isa-em.adoc[]
[.clickable]
****
Learn more about `isa!` statement in TypeQL.
****

.xref:typeql::statements/has.adoc[]
[.clickable]
****
Learn more about `has` statement in TypeQL.
****

.xref:typeql::concepts/types.adoc[]
[.clickable]
****
Learn about types in TypeQL.
****

.xref:typeql::concepts/data-instances.adoc[]
[.clickable]
****
Learn about data instances in TypeQL.
****
--
