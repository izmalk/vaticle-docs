= isa!

The `isa!` keyword is used to specify a direct type for data instances.
For specifying type or supertype of a data instance, using type inference,
see the xref:typeql::statements/isa.adoc[] statement instead.

== Syntax

The syntax of a simple statement with the `isa!` keyword:

.Syntax
[,typeql]
----
<data-instance> isa! <type>;
----

Where `data-instance` can be a concept variable representing a data instance, a literal value representing an attribute,
or both; `type` can be a type label or a concept variable representing a type.

== Usage

TypeQL statements with the `isa!` keyword are used in data queries
to set a type constraint for data instances matched by a concept variable.

== Examples

include::typeql::statements/isa.adoc[tag=example-schema-data]

=== Simple example

To match all data instances of a specific type without any of its subtypes, use the `isa!` keyword.
Let's try matching entities of the `user` type only and fetching values for their attributes:

.isa! statement example 1
[,typeql]
----
match
$u isa! user;
fetch
$u: attribute;
----

We should get no results from this query,
as our <<_examples,sample data>> doesn't have any data instance of the `user` type inserted directly,
only through subtyping.

Now let's replace the `user` entity type for its direct subtype (`person`) in the `match` clause pattern:

.isa! statement example 2
[,typeql]
----
match
$u isa! person;
fetch
$u: attribute;
----

Alternatively, we can switch the `isa!` keyword for the `isa` (without the exclamation mark),
to take into account all subtypes.
The result for our database should be the same:

.Output example
[,json]
----
{
    "u": {
        "attribute": [
            { "value": "Kevin Morrison", "type": { "label": "full-name", "root": "attribute", "value_type": "string" } },
            { "value": "kevin.morrison@typedb.com", "type": { "label": "email", "root": "attribute", "value_type": "string" } }
        ],
        "type": { "label": "person", "root": "entity" }
    }
}
----

The variable `$u` is matched by entities of type `person`.

=== Type variablization example

The `isa!` keyword can be used with a concept-variable instead of a type label to the right.
That sets a constraint on the concept variable to be of any valid, according to the rest of the pattern, type.

.Type variablization example
[,typeql]
----
match
$p isa! $type, has full-name $f;
fetch $type;
----

.Output example
[,json]
----
{ "type": { "label": "person", "root": "entity" } }
----

In the above example, we fetch the `$type` concept variable that represents not a data instance,
but the direct type of `$p`.
As a result of this query, we get all the types of all matched `$p`, but not their supertypes.
To get all their supertypes, use the xref:typeql::statements/isa.adoc[isa] keyword instead of the `isa!`.

== Learn more

[cols-2]
--
.xref:typeql::statements/isa-em.adoc[]
[.clickable]
****
Learn more about `isa!` statement in TypeQL.
****

.xref:typeql::statements/has.adoc[]
[.clickable]
****
Learn more about `has` statement in TypeQL.
****

.xref:typeql::concepts/types.adoc[]
[.clickable]
****
Learn about types in TypeQL.
****

.xref:typeql::concepts/data-instances.adoc[]
[.clickable]
****
Learn about data instances in TypeQL.
****
--
