= Defining rules
:tabs-sync-option:
:experimental:

This page covers defining rules in a schema of a database with Studio, Console, or one of the drivers.
Make sure to xref:manual::installing/overview.adoc[install] and
xref:manual::connecting/connection.adoc[connect] with your chosen client/driver first and to
xref:manual::connecting/database.adoc[create a database] after that.

//#todo Add a link about inference
Rules are used for rule-based inference in TypeDB.
Schema types are used in rules,
make sure to define your database's xref:manual::defining/define.adoc[types] before defining rules.

A rule consists of a label, condition, and conclusion.
Both conditions and conclusions use data patterns and schema types.
Conditions can include any pattern with any number of statements,
but conclusions are quite limited as they can be only one of the following:

* A new relation.
* Ownership of an attribute.
//#todo Add a link to rule theory

== Sending a Define query

The best way to define a rule in a schema is to send a Define query.

See below an example of how to send a simple Define query to a database with the name `db2`:

[tabs]
====
Studio::
+
--
. Use a drop-down list in the top toolbar to select a database with the name `db2`.
. Switch to `schema` session and `write` transaction types.
. Open a new tab and insert or type in a Define query, for example:
+
.TypeQL Define query
[,typeql]
----
define

rule friends: when {
    $u1 isa user;
    $u2 isa user;
    not {$u1 is $u2;};
} then {
    (friend:$u1, friend:$u2) isa friendship;
};
----
. Run the query by clicking the btn:[Run query] button (image:home::studio-icons/run.png[run]).
. Commit the changes by clicking the btn:[Commit query] button (image:home::studio-icons/commit.png[Commit]).
--

Console::
+
--
. Open a session and transaction:
+
[,bash]
----
transaction db2 schema write
----
. Send the Define query:
+
[,bash]
----
define
rule friends:
when { $u1 isa user; $u2 isa user; not {$u1 is $u2;}; }
then { (friend:$u1, friend:$u2) isa friendship; };
----
+
Push btn:[Enter] twice to send the query.
. Commit the changes:
+
[,bash]
----
commit
----
--
====

To send a Define query programmatically, use xref:manual::installing/drivers.adoc[drivers]:

[tabs]
====
Rust::
+
--
[,rust]
----
let query = "define
rule friends: when {
    $u1 isa user;
    $u2 isa user;
    not {$u1 is $u2;};
} then {
    (friend:$u1, friend:$u2) isa friendship;
};";
let databases = DatabaseManager::new(driver);
let db = databases.get("db2")?;
let session = Session::new(db, SessionType::Schema)?;
let tx = session.transaction(TransactionType::Write)?;
tx.query().define(&query).resolve()?;
tx.commit().resolve()?;
----

Where `driver` is an instance of a driver, xref:manual::connecting/connection.adoc[connected] to TypeDB.
--

Python::
+
--
[,python]
----
query = "define" \
"rule friends: when {" \
"    $u1 isa user;" \
"    $u2 isa user;" \
"    not {$u1 is $u2;};" \
"} then {" \
"    (friend:$u1, friend:$u2) isa friendship;" \
"};"
with driver.session("db2", SessionType.SCHEMA) as session:
    with session.transaction(TransactionType.WRITE) as transaction:
        transaction.query.define(query)
        transaction.commit()
----

Where `driver` is an instance of a driver, xref:manual::connecting/connection.adoc[connected] to TypeDB.
--

Java::
+
--
[,java]
----
String query = """
                define
                rule friends: when {
                    $u1 isa user;
                    $u2 isa user;
                    not {$u1 is $u2;};
                } then {
                    (friend:$u1, friend:$u2) isa friendship;
                };
                """;
try (TypeDBSession session = driver.session("db2", TypeDBSession.Type.SCHEMA)) {
    try (TypeDBTransaction Transaction = session.transaction(TypeDBTransaction.Type.WRITE)) {
        Transaction.query().define(query);
        Transaction.commit();
    }
}
----

Where `driver` is an instance of a driver, xref:manual::connecting/connection.adoc[connected] to TypeDB.
--

Node.js::
+
--
[,js]
----
const query =  `define
                rule friends: when {
                    $u1 isa user;
                    $u2 isa user;
                    not {$u1 is $u2;};
                } then {
                    (friend:$u1, friend:$u2) isa friendship;
                };
                `;
session = await driver.session("db2", SessionType.SCHEMA);
transaction = await session.transaction(TransactionType.WRITE);
await transaction.query.define(query);
await transaction.commit();
----

Where `driver` is an instance of a driver, xref:manual::connecting/connection.adoc[connected] to TypeDB.
--

C++::
+
--
[,cpp]
----
std::string query ="define\n"
                   "rule friends: when {\n"
                   "    $u1 isa user;\n"
                   "    $u2 isa user;\n"
                   "    not {$u1 is $u2;};\n"
                   "} then {\n"
                   "    (friend:$u1, friend:$u2) isa friendship;\n"
                   "};";
TypeDB::Options options;
    {
        auto session = driver.session("db2", TypeDB::SessionType::SCHEMA, options);
        auto tx = session.transaction(TypeDB::TransactionType::WRITE, options);
        tx.query.define(query, options).get();
        tx.commit();
    }
----

Where `driver` is an instance of a driver, xref:manual::connecting/connection.adoc[connected] to TypeDB.
--
====

== Rule conclusion

A rule can have one of the two possible conclusion types:

* Creating a new virtual relation.
* Assigning ownership of an attribute.

Since inference works with `read` transactions only, no changes are persisted to a database.
All inferred data exists only virtually, while the transaction is open.

.Rule creating new relation example
[,typeql]
----
rule friends: when {
    $u1 isa user;
    $u2 isa user;
    not {$u1 is $u2;};
} then {
    (friend:$u1, friend:$u2) isa friendship;
};
----

.Rule assigning ownership example
[,typeql]
----
rule default-name: when {
    $u isa user;
} then {
    $u has name "User";
};
----

The above examples show how both types of conclusions.
The first one creates the `friendship` relation between any pair of users.
The second one assigns ownership of attribute with type `name` and value `User`
to any instance of the `user` entity type.

All rules are validated against existing schema for type violations.

== Recursion

Rules can be applied multiple times, including recursively.
The easiest way to show a recursive rule is through arithmetic.

.Schema with a recursive rule
[,typeql]
----
define

file sub entity,
    owns size-kb;

size sub attribute, value long, abstract;
size-kb sub size;

rule recursive-growth: when {
    $f isa file,
        has size-kb $kb;
    $kb < 100;
    ?new-kb = $kb + 1;
} then {
    $f has size-kb ?new-kb;
};
----

The above rule applies to any file that has size in kilobytes less than `100`.
It assigns ownership of a slightly bigger size attribute.
But then it runs again to assign even bigger attribute,
because its condition is met by the attribute assigned in the previous cycle.

[WARNING]
====
Be careful with recursive rules using arithmetic operations.
It is possible to get an infinite recursion.
For example, remove the `$kb < 100;` line from the above example.
====

== Rule chains

Rules can use results from other rules in their conditions.

.Schema with chained rules
[,typeql]
----
define

file sub entity,
    owns size-kb,
    owns size-mb,
    owns size-gb;

size sub attribute, value long, abstract;
size-kb sub size;
size-mb sub size;
size-gb sub size;

rule compute-mb: when {
    $f isa file,
        has size-kb $kb;
    ?mb = round($kb / 1024);
} then {
    $f has size-mb ?mb;
};

rule compute-gb: when {
    $f isa file,
        has size-mb $mb;
    ?gb = round($mb / 1024);
} then {
    $f has size-gb ?gb;
};
----

== Transitivity

Rules can help add transitivity to relations.
If some user is a member of group B, and group B is included in the group A,
then by transitivity, user is a member of group A.
The same is true for any number of nested groups.

.Transitivity example
[,typeql]
----
define

inherited-group-membership sub group-membership;

rule transitive-group-membership:
   when {
      (group: $g1, member: $g2) isa! group-membership;
      (group: $g2, member: $u) isa group-membership;
   } then {
      (group: $g1, member: $u) isa inherited-group-membership;
   };
----

In the example above, we add a new subtype to the relation we add transitivity to for optimization purposes.
