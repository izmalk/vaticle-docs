= Python driver tutorial
:keywords: typedb, typeql, tutorial, python, quickstart, start, sample, example, application, app
:pageTitle: Python driver tutorial
:summary: A sample application using TypeDB Python driver.
:tabs-sync-option:

In this tutorial, we'll build a sample application with the Python driver capable of basic interaction with TypeDB:

* Connect to a TypeDB server (Core or Cloud),
* Delete/create a database,
* Manage sessions and transactions,
* Define a schema,
* Insert data,
* Query data with or without inference.

Follow the steps below or see the
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/python/sample.py[full source code,window=_blank].

== Setup

To run this sample application, you'll need:

. TypeDB: either a https://cloud.typedb.com/[TypeDB Cloud] deployment or a TypeDB Core server.
For TypeDB Core installation instructions, see the xref:home::install/core.adoc[] page.
. Python and https://pypi.org/project/typedb-driver/[TypeDB Python driver].
For the driver installation instructions, see the xref:drivers::python/overview.adoc[] page.

== Program structure

The main workflow of this sample application includes establishing a connection to TypeDB,
database setup, and querying.

.Example
[,python,indent=0]
----
include::drivers::partial$tutorials/python/sample.py[tag=main]
----

The entire `main()` function code is executed in the context of the network connection
established by the `connect_to_typedb()` function.
The network connection is represented by the `driver` object that is returned by the function.

== TypeDB connection

The `connect_to_typedb()` function takes `edition` and `addr` as mandatory parameters.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=connection]
----

The `edition` is expected to be a Enum for selecting a TypeDB edition.
Depending on the TypeDB edition selected, this function initializes either a TypeDB Core or TypeDB Cloud connection.
Both require server address, passed in the `addr` parameter.

TypeDB Cloud connection requires `credentials` object of type `TypeDBCredential`
that is initialized with a username and password.
For our sample application,
we have the default credentials for the `admin` account provided as default values for the optional parameters.

== Database setup

To set up a TypeDB database, we need to create a database on the TypeDB server,
define its schema and load initial data into it.
Additionally, we test it to make sure that the setup process is completed successfully.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=db-setup]
----

=== Creating a database

For this sample application we create a new database of the default name `sample_app_db`
in the `create_new_database()` function.
But first, we check whether a database with such a name already exists.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=create_new_db]
----

If there is no such database, we just create a new database.
But if there is one, we ask user's confirmation on how to proceed.

By default, the `db_reset` is set to False (the default behavior).
In combination with a pre-existing database,
that leads to requesting the user's input on whether to replace the existing database with a new one.

If a user gives confirmation for the replacement, we delete the existing database (with all of its schema and data)
by restarting the `create_new_database` function with the `db_reset` parameter set to True.

If a user doesn't want to delete the existing database,
we proceed further without modification of the existing database.
This will most likely lead to failing the database setup phase that comes next,
but it prevents us from loosing existing data.

=== Defining a schema

After our database is created (or user decided to re-use an existing database with the same name),
we use a xref:typeql::schema/define.adoc[Define query] to define a schema for that database.
See the `db_schema_setup()` function:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=db-schema-setup]
----

The schema for the sample application is stored in the file
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/attachments/iam-schema.tql[iam-schema.tql,window=_blank],
so we read the file first.

.See the full schema listing
[%collapsible]
====
[,typeql]
----
include::drivers::attachment$iam-schema.tql[lines=17..]
----
====

We use a session object passed as a parameter to open a transaction.
Then we send the contents of the file as a TypeQL Define query and commit the changes made by the transaction.

=== Loading initial data

With a schema defined, we can load initial data into our database with an xref:typeql::data/insert.adoc[Insert query].
See the `db_dataset_setup()` function:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=db-dataset-setup]
----

We do it the very same way: read the file
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/attachments/iam-data-single-query.tql[iam-data-single-query.tql,window=_blank]
and send it as a single query, and then commit the changes.

.See the full Insert query listing
[%collapsible]
====
[,typeql]
----
include::drivers::attachment$iam-data-single-query.tql[lines=17..]
----
====

=== Testing a database

With the schema defined and data loaded, we test our database to make sure it's ready.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=test-db]
----

To test the database, we send a query to count the number of users in the database.

== Querying

After database setup is complete, we proceed with querying our database with different types of queries:

. <<_fetch,Fetch query>> -- to get attribute values in JSONs
. <<_insert,Insert query>> -- to add new data
. <<_get,Get query>> -- to get stateful objects
. <<_get_infer,Get query with inference>> -- to get stateful objects with inference
. <<_update,Update query>> -- to replace data
. <<_delete,Delete query>> -- to delete data

Every query is implemented as a function that includes visualisation of the query response
and returns some meaningful data.

[#_fetch]
=== Fetch query

The main way to retrieve data from a TypeDB database is to use fetching to get values of attributes,
matched by a pattern.

Let's use a xref:typeql::data/fetch.adoc[Fetch query] to fetch names and emails for all users in the database:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=fetch]
----

We collect response in a list and store it in the `users` variable that is returned by the function.
We iterate through the list and print the results from every JSON in the list.

Since we know that there is only one name and one email every time, we can print only the first element every time.
In general case, there can be multiple attributes of the same type owned,
so we need to consider iterating through all returned values returned for every attribute in every JSON.
That can be done as in the following example:

.Printing JSON for any number of attributes fetched
[,python]
----
for i, JSON in enumerate(users, start=0):
    print(f"User #{i + 1} â€”", end="")
    for result in JSON['u']['full-name']:
        print(f" Full-name:", result['value'], end="")
    for result in JSON['u']['email']:
        print(f" E-mail:", result['value'], end="")
    print()
----

[#_insert]
=== Insert query

Let's insert a new user with `full-name` and `email` attributes to the database.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=insert]
----

We collect the response of the xref:typeql::data/insert.adoc[Insert query] as a list
and use it to print the inserted data after we commit the transaction.

We iterate through the response, retrieve attribute values and print them for every return result.
Since the Insert query has no `match` clause, the `insert` clause is executed exactly once.
But the Insert query always returns a list of ConceptMap objects, where every ConceptMap represents an inserted result.

[#_get]
=== Get query example

Let's retrieve all files available for a user with a `get_files_by_user()` function.
It can be used with or without inference enabled.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=get]
----

We call the function without enabling the inference and expect it to return no results, as the query pattern
matches only files available for `view_file` action, and there are no such files initially in the database.

The `get_files_by_user()` function checks
that there is only one user matched with the name provided by an input parameter.
It then executes the query and iterates through the list of results to print a value of every matched `path` attribute.

[#_get_infer]
=== Inference example

To get query results with inference, we set the `infer` parameter of the TypeDB transaction options to True.
We use the same `get_files_by_user()` function, but set the `inference` parameter to True when we call it again.
The `add-view-permission` should provide us with some results this time,
thanks to the `add-view-permission` rule in the schema.

[#_update]
=== Update query example

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=update]
----

[#_delete]
=== Delete query example

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=delete]
----
