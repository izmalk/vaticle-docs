= 5.1 - Patterns as constraints

== Introduction to patterns

TypeQL uses *pattern matching* as the basis for all data queries. Patterns are defined in the `match` clause of queries, with subsequent clauses determining the action that should be taken for each match found. The following is an example of a pattern:

[,typeql]
----
$book isa paperback,
    has isbn-13 "isbn placeholder",
    has page-count $count;
----

Each of the following queries has this pattern in the `match` clause but is of a different kind: a Fetch query, an Insert query, a Delete query, and an Update query respectively. Try to examine them and determine what they do.

[,typeql]
----
# Example of a Fetch query
match
$book isa paperback,
    has isbn-13 "isbn placeholder",
    has page-count $count;
fetch
$count;
----

[,typeql]
----
# Example of an Insert query
match
$book isa paperback,
    has isbn-13 "isbn placeholder",
    has page-count $count;
insert
$book has title "placeholder title";
----

[,typeql]
----
# Example of a Delete query
match
$book isa paperback,
    has isbn-13 "isbn placeholder",
    has page-count $count;
delete
$book has $count;
----

[,typeql]
----
# Example of an Update query
match
$book isa paperback,
    has isbn-13 "isbn placeholder",
    has page-count $count;
delete
$book has $count;
insert
$book has page-count 245;
----

All the queries search for paperbacks with the ISBN-13 "isbn placeholder" and a page count (of any value) and then performs an action per match found:

* The Fetch query returns the number of pages for each book.
* The Insert query assigns each book a new title "placeholder title".
* The Delete query deletes the page count of each book.
* The Update query replaces the existing page count of each book with a new one of 245.

In this particular case, only one book will be found by any of these queries because `isbn-13` is a key attribute of `paperback` (as described by the `@key` annotation in the schema), but in principle, these queries could match multiple books. It is important to remember that a pattern can always find multiple matches unless you ensure that only one match can be found, for example by leveraging key attributes. This will be discussed further in xref:learn::5-pattern-based-querying/5.8-semantics-of-solution-spaces.adoc[Lesson 5.8].

== Constraint satisfaction

Every pattern is equivalent to a list of *constraints* that must be simultaneously satisfied. Let's consider the previous pattern. We'll break it down into an equivalent pattern composed of atomic statements to make it easier to interpret.

[,typeql]
----
$book isa paperback;
$book has isbn-13 "isbn placeholder";
$book has page-count $count;
----

This pattern represents several constraints about the *terms* involved, where a term can be either a variable or a literal:

1. The variable `$book` is of type `paperback`.
2. The literal `"isbn placeholder"` is of type `isbn-13`.
3. The variable `$book` owns the literal `"isbn placeholder"`.
4. The variable `$count` is of type `page-count`.
5. The variable `$book` owns the variable `$count`.

Because these constraints must be satisfied simultaneously, it is especially important to note that constraint (5) specifies that the book has a page count. This means that books without page counts _cannot_ be matched by this pattern and _will not_ be returned. There are ways to perform optional attribute matches that will be explored fully in xref:learn::6-reading-data/6-reading-data.adoc[Lesson 6].

[NOTE]
====
In TypeDB 2.x, the `match` clause of all queries uses all-or-nothing pattern matching, meaning that every constraint must be satisfied simultaneously. Syntax for generalised optional pattern matching will be introduced in TypeDB 3.0, which will allow some constraints to be matched only if possible.
====

== Resolving types

In the previous pattern, we could very easily tell the type of each term, as described by constraints (1), (2), and (4). But this is not the case for every pattern. Consider this far more complex pattern from xref:learn::3-running-your-first-queries/3.3-retrieving-types-of-data-instances.adoc[Lesson 3.3]. What is the type of `$user`?

[,typeql]
----
$rating (rater: $user, rated: $book) isa rating;
$publish (publisher: $publisher, published: $book) isa publishing;
$user-loc (place: $state, located: $user) isa location;
$pub-loc (place: $state, located: $publish) isa location;
$state isa state;
----

We cannot actually tell just by reading the query! So how is it that TypeDB resolves this pattern? TypeDB is able to *infer* the correct types for `$user` from the information the pattern provides. Let's consider what we _can_ tell about `$user` from this query:

* `$user` must be of a type that plays `rater` in `rating`.
* `$user` must be of a type that plays `located` in `location`.

This is more than enough information to work out the type of `$user` because the schema provides the context we need:

* Only `user` plays `rater` in `rating`.
* `user`, `publishing`, `place`, `state`, and `city` all play `located` in `location`.

Because the pattern's constraints must be satisfied simultaneously, `$user` can only possibly be of type `user`! This is roughly how the type inference process works. As an exercise, try identifying the types of the terms `$book` and `$publisher` in this way, which also don't have their types explicitly stated.

== Pattern validation

In addition to allowing us to use implicit typing, type inference also allows patterns in queries to be validated for semantic correctness. Consider the following pattern.

[,typeql]
----
$person has name $name;
$order (buyer: $person, product: $book) isa order;
----

We haven't explicitly specified the type of `$person` here, so we will have to infer it. We can identify the following two relevant constraints (amongst others):

* `person` must be of a type that owns `name`.
* `person` must be of a type that plays `buyer` in `order`.

If we then examine the schema, we can see the following:

* `contributor`, `publisher`, `place`, `state` and `city` all own `name`.
* Only `user` plays `buyer` in `order`.

Once again, all the constraints must be satisfied simultaneously, but here we run into a problem: there is no type that both owns `name` and plays `buyer` in `order`! This means that there are no possible types for the term `$person`, and so the pattern cannot possibly generate any matches. Despite the fact the pattern appears to be well-constructed at face value, it fails validation by type inference. As a result, TypeDB recognises that the pattern must be malformed, and running a query containing this pattern would cause an error to be thrown. This will also occur for patterns that are trivially unsatisfiable, for example the following.

[,typeql]
----
$x isa book;
$x isa publisher;
----

Naturally, it is not possible for the variable `$x` to simultaneously represent both a book and a publisher!
