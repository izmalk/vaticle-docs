= 3.1 - Retrieving attributes of entities

== The Fetch query

To begin with, we'll use the following *Fetch query* to retrieve all data relating to paperback books in the database.

[,typeql]
----
match
$book isa paperback;
fetch
$book: attribute;
----

This is equivalent to the following SQL query.

[,sql]
----
SELECT *
FROM paperback;
----

This TypeQL query comprises two *clauses*: a `match` clause and a `fetch` clause.

The `match` clause is equivalent to a *selection* in SQL. It identifies what entity types (tables) we wish to retrieve data from. It can also specify further constraints that the retrieved data must meet, as we'll see shortly. The `fetch` clause is equivalent to a *projection* in SQL. It specifies what attributes (columns) we would like to retrieve for the entities (rows) identified. In this case, we've chosen to retrieve _all_ attributes.

Using a *data* session and *read* transaction, *run* image:learn::studio-icons/run.png[] this query. You should see the following result.

[,json]
----
result placeholder
----

All Fetch queries return results in JSON format.

In the `match` clause of the query, we declared a single *variable*: `$book`. In TypeQL, variables are declared using the `$` prefix. We also specified the *type* of `$book` (`paperback`) using the `isa` keyword. We can see that each JSON object returned represents an instance of `paperback` (i.e. a paperback book), and contains a list of all that book's attributes.

== Projections

Looking at the list of each book's attributes in the previous result, we can see that we've retrieved attributes of four types: `title`, `page-count`, `isbn-10`, and `isbn-13`. By modifying the `fetch` clause, we can choose to retrieve only specific attributes.

[,typeql]
----
match
$book isa paperback;
fetch
$book: title, page-count;
----

If we *run* image:learn::studio-icons/run.png[] this query, we see the following result:

[,json]
----
result placeholder
----

This time, only the titles and page counts of each book have been retrieved. The structure of the output has also changed slightly, which will be covered in-depth in xref:learn::6-reading-data/6.1-fetch-queries.adoc[Lesson 6.1]. Now this TypeQL query is equivalent to the following SQL query.

[,sql]
----
SELECT title, page_count
FROM paperback;
----

== Selections

In the next query, we'll add a *constraint* to the `match` clause, specifying that we want the details for a specific book with ISBN-13 `"isbn placeholder"`.

[,typeql]
----
match
$book isa paperback, has isbn-13 "isbn placeholder";
fetch
$book: title, page-count;
----
[,json]
----
result placeholder
----

We can see from the result that we now only retrieve the data for the specific book we're interested in. To do so we've used the `has` keyword, which is used to specify the value of an entity's attribute, in this case the `$book` entity. In SQL, this query would be expressed in the following way.

[,sql]
----
SELECT title, page_count
FROM paperback
WHERE isbn_13 = 'isbn placeholder';
----

Because TypeQL is *composable*, we could alternatively construct this query in the following equivalent way.

[,typeql]
----
match
$book isa paperback;
$book has isbn-13 "isbn placeholder";
fetch
$book: title, page-count;
----

Try *running* image:learn::studio-icons/run.png[] these two queries. You should get the same results.

In the first version, we used a single compound *statement* in the `match` clause, whereas in the second version, we instead used two atomic statements. If atomic statements concern the same variable, we can always concatenate them using commas, and vice versa.

== Type inference

The entities we've retrieved have all been of the same `paperback` type. However, with TypeDB we can also query instances of types indirectly by querying their *supertypes*. In the following query, we retrieve the details for all books: paperbacks, hardbacks, and ebooks, by changing the type of `$book` from `paperback` to `book`.

[,typeql]
----
match
$book isa book;
fetch
$book: title, page-count;
----
[,json]
----
result placeholder
----

If we examine the results, we see that each result includes a `type` field for the book (plus additional `type` fields for the attributes of the book). In previous queries, this field always had the following form because we were directly querying for instances of the `paperback` type.

[,json]
----
result placeholder
----

The `label` field indicates the name of the book's type, and the `root` field indicates the type's *root type*: `entity`, `relation`, or `attribute`.

The `type` field in the results of this last query show we are retrieving data instances of different types: `paperback`, `hardback`, and `ebook`. This is because all three of these types are *subtypes* of `book`, which was the type we queried for. In fact, we have already seen this feature at play. In the first query, we retrieved attributes of multiple types by directly querying the root type `attribute`, from which all attribute types are subtyped. The entity, relation, and attribute type hierarchies are defined in the *schema*, which we'll be exploring in xref:learn::4-designing-schemas/4-designing-schemas.adoc[Lesson 4].

The ability to retrieve all books without having to explicitly specify every specific book subtype is called *type inference*, and unique to databases with polymorphic capabilities. Consider, in a relational database, the SQL query would need to be explicit, as shown here.

[,sql]
----
SELECT title, page_count
FROM paperback
UNION
SELECT title, page_count
FROM hardback
UNION
SELECT title, page_count
FROM ebook;
----

We'll be exploring the ways in which we can compose polymorphic queries in xref:learn::5-pattern-based-querying/5-pattern-based-querying.adoc[Lesson 5].
