= 4.1 - Conceptual modeling

== Conceptual, logical, and physical models

In database design, there are normally three separate models for each database: the conceptual, logical, and physical models.

The *conceptual model* describes the data domain in human terms. It is entirely independent of software and hardware used to run the database. It is used to draft and plan out the data model, and captures the business logic of the domain in a way that subject-matter experts can understand even with no programming experience. The most widely adopted conceptual modeling paradigm is https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model[Chen's Entity-Relationship model] (ER model). It is most often represented using an entity-relationship diagram (ER diagram or ERD).

The *logical model* describes the implementation of the data domain in terms of the database management system (DBMS) in use. It is independent of the hardware used to run the database. For relational databases, this is in terms of tables, columns, and foreign keys. It is constructed by translating the conceptual model, typically by a database architect. The business logic of the data domain must be modeled in terms of constraints provided by the DBMS. Some of the most common logical data modeling paradigms (i.e. database paradigms) are the relational model, the document model, the key-value model, the triplestore model, and the graph model.

The *physical model* describes how the data is stored on disk. It is tightly coupled to both the DBMS and hardware used to run the database, and may differ between architectures and operating systems running the same DBMS. Modern DBMSs do not require database architects to plan physical models, which are implemented automatically by the DBMS based on the logical model. Database architects may sometimes alter properties of the physical model to optimise database performance according to available functionalities of the DBMS, such as by adding or removing indexes.

== The conceptual PERA model

One of the problems with contemporary database paradigms is the need for translation between the conceptual and logical models. In relational databases, this is known as *normalisation*. Similar terms, such as *reification*, may be applied to conceptual-logical translations in other database paradigms. This leads to some of the https://typedb.com/fundamentals/why-polymorphic-database[hardest challenges] in data engineering, particularly when dealing with polymorphic data.

TypeDB avoids this issue by implementing the https://typedb.com/fundamentals/polymorphic-data-model[Polymorphic Entity-Relation-Attribute model] (PERA model), an extension of the ER model with dependently typed attributes and polymorphic data structures. The PERA model is a conceptual data model, and there is no separate logical model in TypeDB: the conceptual model _is_ the logical model. This allows database designers to model their data only once and avoid lossy translation processes like normalisation and reification. Because object models in applications are conceptual in nature, there is no mismatch between the database model and application model.

== Entities, relations, and attributes

A PERA model comprises *types* and *interfaces* between them, similar to classes and interfaces in OOP. All types in the PERA model are either entity types, relation types, or attribute types. Each is used to model a different concept in the data domain.

*Entity types* are used to represent classes of *independent objects*. An entity might practically require other concepts to exist, such as a car that cannot exist without its parts, but can be conceptualized without reference to them: a car can be imagined without considering its parts.

*Relation types* are used to represent classes of *objects dependent on other objects*. Every relation must depend on at least one other concept, and cannot be conceptualized without those dependencies: it is impossible to imagine a marriage without considering its spouses. The dependency of a relation type on another object type is described by a *role interface*, and an object type that implements it is a *roleplayer* of that role. In the case of marriages, the role would be "spouse", but there could also be other roles such as "officiant" or "witness".

*Attribute types* are used to represent classes of *values dependent on objects*. They represent properties of those objects, such as names of people, dates of marriages, and license plates of cars. Every attribute has a literal value, for instance a string, a number, or a boolean. The dependency of an attribute type on object types is described by an *ownership* interface, and an object type that implements it is an *owner* of that attribute [#_footnote_1]#type#^<<_footnotes,1>>^. Unlike relation types which can have several role interfaces, all attribute types only have a single ownership interface.

[IMPORTANT]
=====
We use the terms "entity type", "relation type" and "attribute type" to refer to types, and the terms "entity", "relation", and "attribute" to refer to respective _instances_ of those types.
=====

== PERA diagrams

PERA models can be represented with PERA diagrams, in the same way that ER models can be represented with ER diagrams. In a PERA diagram, entity types are represented by rectangles, relation types by diamonds, and attribute types by ovals. Interfaces between types are represented by connecting arrows. Role interfaces are labeled with the name of the role, while ownership interfaces are labeled with the word "owns".

image::pera-diagrams/example-diagram-1.png[role=framed, width = 75%, link=self]

In TypeDB documentation, colour coding is also used to improve clarity. Entity types are shown in pink, relation types in yellow, and attribute types in blue. Interfaces are shown in the same colour as the types that depend on them: yellow for roles and blue for ownerships.

https://en.wikipedia.org/wiki/Cardinality_(data_modeling)[Cardinality] can be indicated by adding a number in brackets to the start or end of an interface arrow. Two numbers separated by a comma represent a lower and upper bound. An asterisk is used to represent "many" cardinality. Cardinality annotations may be omitted in PERA diagrams, especially in more complex ones, but should always be considered when designing a model.

The PERA model is strictly more expressive than the ER model, so any ER diagram is automatically also a PERA diagram (though notation may differ slightly) and could be immediately implemented as a TypeDB schema. This is not best practice as such a schema would not leverage features exclusive to the PERA model, such as subtyping.

== Comparing objects and values

A key difference between entity or relation types and attribute types is that entity and relation types contain *objects* whereas attribute types contain *values*. Objects are freely instantiable, so it is possible to create two objects that have identical properties but are not themselves identical. Meanwhile, values are not freely instantiable: all values already exist, even if not recorded in the database, and it is not possible to invent new ones, such as a new string or a new number. For this reason, two attributes with the same type and value are in fact _the same_ attribute.

This difference also affects permitted *dependencies* in the PERA model. Only objects (entities or relations) can have attributes as properties, and relations can only depend on other objects. It is not possible to have an attribute of another attribute, or a relation depending on an attribute.

Entity and relation types can be collectively referred to as *object types*.

image::pera-diagrams/objects-vs-values.png[role=framed, width = 75%, link=self]

== Distinguishing entities and relations

Practically, the difference between entity and relation types is highly dependent on the data domain. Considering the previous examples, a database in a car manufacturing plant might model a car as a relation between its parts, while a catering company might model a marriage as an entity, the spouses being irrelevant to their data. Whether one object depends on another object or not depends on the object's conceptual description in the domain.

image::pera-diagrams/example-diagram-2.png[role=framed, width = 75%, link=self]

The above examples of cars and marriages were chosen because they would almost always be modeled as entities and relations respectively, and the opposite cases would be a rarity in most data domains. However, there are cases where it can be unclear whether a concept should be an entity type or a relation type. Consider a team of people. In some cases, it might be useful to model a team as a relation between its members, whereas in other it might be useful to model it as an entity related to its members by "team membership" relations.

image::pera-diagrams/role-vs-relation.png[role=framed, width = 75%, link=self]

The difference between these two cases is that, if teams are relations, then they cannot be instantiated without at least one member, whereas if teams are entities, then they can be instantiated independently. This can be seen by the change in cardinality notation, as it is not possible to instantiate a relation without at least one roleplayer. If it is ever unclear if a concept should be modeled as an entity type or relation type, then the best practice is to consider if it should be independently [#_footnote_2]#instantiable#^<<_footnotes,2>>^.

== Inheritance and abstraction

The biggest difference between the ER and PERA models is that the PERA model permits the use of polymorphic features like inheritance and abstraction.

*Inheritance* allows types to be made *subtypes* of other types, with respect to their root types (e.g. entity types can only be subtypes of other entity types). Capabilities of types are *inherited* by their subtypes, namely the owning of attributes and the playing of roles. For instance, in the PERA diagram below, registrars, dentists, and artists can all have names and get married because they inherit these capabilities from their supertype "person". Meanwhile, only registrars and dentists can have license numbers, and only registrars can officiate marriages.

*Abstraction* is used to prevent instantiation of a type. An abstract type cannot be directly instantiated. Instead, it must be instantiated through a concrete subtype. In the diagram below, it is not possible to directly instantiate a person. All people must be either registrars, dentists, or artists.

In PERA diagrams, subtyping is represented by a dotted line, and abstract types are represented with a dotted outline.

image::pera-diagrams/example-diagram-3.png[role=framed, width = 75%, link=self]

Entity, relation, and attribute types can all be subtyped or made abstract. This will be explored further in Lessons xref:learn::4-designing-schemas/4.2-defining-entity-types.adoc[4.2], xref:learn::4-designing-schemas/4.3-defining-relation-types.adoc[4.3], and xref:learn::4-designing-schemas/4.4-defining-attribute-types.adoc[4.4] respectively. There are certain caveats related to inheritance of interfaces that will also be discussed. One important distinction to be made is that only an abstract attribute type can have subtypes. This is not the case for object types, which can be subtyped or made abstract independently.

image::pera-diagrams/subtyping-attributes.png[role=framed, width = 75%, link=self]

== Quick reference

All the key features of the conceptual PERA model are described on this page. The following figures provide a quick reference for the root type functionalities and PERA diagram design.

image::pera-diagrams/root-type-comparison.png[role=framed, width = 75%, link=self]
image::pera-diagrams/diagram-template.png[role=framed, width = 75%, link=self]

[#_footnotes]
== Footnotes

1. <<_footnote_1,^>> The astute reader may notice that we have accounted for independent objects (entities), dependent objects (relations), and dependent values (attributes), but not independent values. In a data domain, such independent values might be considered *global constants*. Practically, global constants can be represented by attributes without owners, and are not specifically distinguished.

2. <<_footnote_2,^>> It is also worth noting there is an additional practical consideration, in that it is possible for relations to own attributes but not for roles to do so. In the example of team memberships, this means that if we wanted to record information about the membership, for instance the date that the person joined the team, then we cannot do this if the membership is a role. In such a situation, we would want to make the membership a relation.
