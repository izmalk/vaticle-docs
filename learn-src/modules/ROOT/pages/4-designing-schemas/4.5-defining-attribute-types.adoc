= 4.5 - Defining attribute types

== Value types

Unlike entity and relation types, which contain objects, attribute types contain values. This means that attribute types must always be defined along with a specified *value type*. The following query defines seven new attribute types.

[,typeql]
----
define
title sub attribute, value string;
page-count sub attribute, value long;
id sub attribute, value long;
age sub attribute, value long;
timestamp sub attribute, value datetime;
score sub attribute, value long;
success sub attribute, value boolean;
----

When used in a Define query, the `value` keyword defines the value type of an attribute type. When the attribute type is instantiated, its values must be of the specified value type. There are currently five value types in TypeDB:

* `boolean`
* `long` (64-bit signed integer)
* `double` (64-bit floating point number)
* `string` (variable length UTF-8 encoded string up to 64 kB)
* `datetime` (millisecond-precision timestamp without timezone)

More value types will be added in future updates. So far, we have not defined any owners of these attribute types. This will be covered in xref:learn::4-designing-schemas/4.6-defining-owners-and-roleplayers.adoc[Lesson 4.6]. Unlike with relation types, which must have their role interfaces explicitly defined, we do not need to define the ownership interface of attribute types as they are defined by default.

Like all other statements in TypeQL, compound statements involving the `value` keyword can be made atomic, as in the following example.

[,typeql]
----
define
name sub attribute;
name value string;
year sub attribute;
name value long;
----

However, this is not considered best practice. As attribute types must always be specified with a value type, the compound-statement form is preferred for clarity.

== Defining attribute type hierarchies

In order to define subtypes of a given attribute type, the supertype must be *abstract*. This is to prevent potential ambiguities in the interpretation of queries. In the following query, we define an attribute type with two subtypes.

[,typeql]
----
isbn sub attribute,
    abstract,
    value string;
isbn-13 sub isbn;
isbn-10 sub isbn;
----

The value type `string` of `isbn` is inherited by its subtypes `isbn-13` and `isbn-10`, so they do not need their value types specified.

[NOTE]
====
In TypeDB 2.x, all attribute types in a hierarchy must have the same value type, as specified in the definition of the supertype. In TypeDB 3.0, it will be possible to create abstract attribute types that do not have a value type, and to assign different value types to their subtypes.
====

== Value constraints

The values of string attribute types can be constrained with the `regex` keyword, which specifies a https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html[Java regex pattern] string that is validated against when instantiating the attribute type. In the following example, we require that the value of `status` instances must be one of `"paid"`, `"dispatched"`, `"delivered"`, `"returned"`, or `"canceled"`.

[,typeql]
----
status sub attribute,
    value string,
    regex "^(paid|dispatched|delivered|returned|canceled)$";
----

[NOTE]
====
The `regex` constraint is the only value constraint in TypeDB 2.x. TypeDB 3.0 will feature other value constraints, such as ranges for numeric values and enums.
====
