= 4.3 - Defining entity types

== The Define query

With the data model for the bookstore complete, we can now go about implementing it as a TypeQL schema. In TypeDB, all databases have a schema that provides semantic integrity guarantees for inserted data and enables the resolution of polymorphic queries. A schema is created using *Define queries*, which are each composed of a single `define` clause.
We'll start with the syntax for defining entity types, then look at relation types in xref:learn::4-designing-schemas/4.4-defining-relation-types.adoc[Lesson 4.4], and at attribute types in xref:learn::4-designing-schemas/4.5-defining-attribute-types.adoc[Lesson 4.5]. The following is an example of a Define query that defines three new entity types.

[,typeql]
----
define
book sub entity;
contributor sub entity;
publisher sub entity;
----

When used in a Define query, the `sub` keyword defines a new type. The type must be a subtype of an existing type, either one of the three built-in *root types* or a previously user-defined type. Each of the three atomic statements above defines a new type, `user`, `contributor`, and `publisher`, as a subtype of the root type `entity`. The statements in a `define` clause are *data definition statements* as opposed to the *data manipulation statements* used in `match` clauses. A data definition statement cannot contain any variables, so the only permitted terms are keywords and type names.

[NOTE]
====
The sample database already has the complete bookstore schema defined and data inserted. If you would like to try running any of the Define queries shown in this section, then it is recommended you do so using a new database. xref:learn::2-learning-environment-setup/2.2-get-started-with-typedb-studio.adoc[Create a new database], and then *run* image:studio-icons/run.png[] the query using a *schema* session and *write* transaction. After running any queries, remember to *commit* image:studio-icons/commit.png[] the changes or *close* image:studio-icons/close.png[] the transaction. If you are using TypeDB Studio, you should see any committed changes to the schema reflected in the *type browser*.
====

== Defining type hierarchies

In order to define new subtypes of a previously defined type, we use the same syntax but replace the root type with the intended supertype. In the following query, we define the three subtypes of `book`.

[,typeql]
----
define
paperback sub book;
hardback sub book;
ebook sub book;
----

They will inherit all the capabilities of `book`, though we haven't assigned any yet. We will explore how capabilities are assigned in xref:learn::4-designing-schemas/4.6-defining-owners-and-roleplayers.adoc[Lesson 4.6].

== Defining abstract types

To make a type abstract, we use the `abstract` keyword. The following query makes the existing type `book` abstract.

[,typeql]
----
define
book abstract;
----

Now it is impossible to instantiate `book` directly. We can only do so by instantiating one of its subtypes: `paperback`, `hardback`, or `ebook`.

== Composing definitions

As with all TypeQL queries, Define queries are composable. If atomic data definition statements concern the same type, we can always concatenate them into a single compound statement using commas, and vice versa. Similarly, the order in which the statements appear in a query does not matter, nor does the use of newlines or indentation. The following Define queries will have identical effects when run.

[,typeql]
----
define
place sub entity, abstract;
state sub place;
city sub place;
----

[,typeql]
----
define
place sub entity,
    abstract;
state sub place;
city sub place;
----

[,typeql]
----
define
place sub entity;
place abstract;
state sub place;
city sub place;
----

[,typeql]
----
define
place abstract;
state sub place;
place sub entity;
city sub place;
----

For code clarity, it is advisable to use compound statements where possible, and to keep statements in a logical order.
