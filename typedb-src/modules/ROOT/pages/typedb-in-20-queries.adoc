= TypeDB in 20 queries
//:toc: macro
//:toclevels: 5
//:toc-title: Top query examples:
:example-caption!:

This page is full of TypeQL query examples to showcase TypeDB features.
Feel free to try any of the examples yourself.

If you are not sure how to send a query to TypeDB, check our xref:typedb::quickstart-guide.adoc[].
For more information about sending queries to TypeDB, check the
xref:typedb::development/connect.adoc[] page.

To learn more about the queries, check the links in the respective section.

To showcase the capabilities of TypeDB and its query language TypeQL,
see below a short list of example queries designed to give a brief idea of what can be done and how easy it is.

//toc::[]

[#_pera]
== #{counter:query}: PERA model

TypeDB uses Polymorphic Entity-Relation-Attribute (or PERA) model for its schemas and data.

Entities, relations, and attributes are all first-class citizens in a data model allowing for
expressive modeling without normalization or reification.
There are three root types: `entity`, `relation`, and `attribute`;
and they can be subtyped to create user-defined types.

All data stored in a database must be instantiated from types, defined in a schema of a database.

Let's use the following schema definition as example.

[NOTE]
====
Use our xref:typedb::quickstart-guide.adoc[Quickstart guide]
to find out how to create a new database and send the query.
====

[#_pera_schema]
.Schema
[,typeql]
----
define

person sub entity,
    owns full-name;
user sub person,
    owns email @unique,
    owns name @key,
    plays permission:subject;
file sub entity,
    owns path @key,
    owns size-kb,
    plays permission:object;

permission sub relation,
    owns updated,
    relates subject,
    relates object;

full-name sub attribute, value string;
id sub attribute, abstract, value string;
email sub id;
path sub id;
name sub id;
size-kb sub attribute, value long;
updated sub attribute, value datetime;
----

The above TypeQL fragment is a xref:typeql::schema/define-types.adoc[Define] query that defines a few types:
four entity types, two relation types, and six attribute types.
The Define query above can be used in an empty TypeDB database, because it is self-sufficient.
But if at any time you decide to extend or modify your schema in an existing database, you can do it easily:
see the <<_counterquery_extending_the_schema>> section below.

.Visualize a schema in TypeDB Studio
====
To retrieve all types of a schema from a database it is sufficient to query for all subtypes of the root types:
`entity`, `relation`, and `attribute`.
The following query works with any TypeDB database and any schema:

.Retrieve schema types
[,typeql]
----
match
    $t sub $r;
    {$r sub entity;} or {$r sub relation;} or {$r sub attribute;};
----

The above query returns all types of a schema defined in a database.

If you send the above query with TypeDB Studio, you can get the following graph visualization.

image:typedb-in-20-queries/era-schema.png[era-schema, width=50%, link=self]
====

The above Define query

.Insert sample data
====
To insert some sample data into a database with the schema above, you can use the following insert queries:

.Insert sample data
[,typeql]
----
insert
    $u isa user,
        has email "bob@vaticle.com";
    $f isa file,
        has path "docs/README.md";
     $p(subject:$u, object:$f) isa permission;
----

The above query inserts a single instance of `user` entity type and a single `file` entity,
each owning a single attribute, and a relation between the two entities.

Use our xref:typedb::quickstart-guide.adoc[Quickstart guide] to find out how to create a new database
and send the queries above.
====

.Retrieve some data
====
To retrieve the inserted data, use the Get query:

.Get sample data
[,typeql]
----
match
    $u isa user,
        has email $e;
    $f isa file,
        has path $path;
     $p(subject:$u, object:$f) isa permission;
----

For the query, the schema and the data above, see the result below.

image:typedb-in-20-queries/era-data.png[era-data, width=50%, link=self]
====

[#_declarative]
== #{counter:query}: Composable patterns

TypeQL statements are combined with a conjunction, which makes patterns fully-composable.
You can combine multiple patterns to extend or filter results of a query.

// tag::preload[]
[NOTE]
====
To run queries from this section, use a database with the schema and data from the <<_pera>> section.
====
// end::preload[]

Given the schema and data from previous query (<<_pera>>), let's explore the following queries:

.Query 1
[,typeql]
----
match
    $u isa user,
        has email "bob@vaticle.com";
----

The above query returns all instances of the `user` type
that own an instance of the `email` type with exact value of `bob@vaticle.com`.

.Query 2
[,typeql]
----
match
    $f isa file,
        has path "docs/README.md";
----

The above query returns all instances of the `file` type
that own an instance of the `path` type with exact value of `docs/README.md`.

Now let's combine the previous two queries:

.Query 3
[,typeql]
----
match
    $u isa user,
        has email "bob@vaticle.com";
    $f isa file,
        has path "docs/README.md";
    (subject:$u, object:$f) isa permission;
----

The above query matches all users
that have the `email` of `bob@vaticle.com` and participate in a `permission` relation with a `file`
type entity, that has the `path` attribute `docs/README.md`.

As you can see, we combined two patterns: one two find users and another one to find files,
by using a relation between them.

[#_counterquery_inserting_data_with_or_without_context]
== #{counter:query}: Inserting data with or without context

An xref:typeql::data/insert.adoc[Insert] query can be used with or without a `match` clause, as it is optional.

include::typedb-in-20-queries.adoc[tag=preload]

Let's insert some data directly:

.Insert query
[,typeql]
----
insert
    $u isa user,
        has email "john@email.com";
    $f isa file,
        has path "insert.py";
    (subject:$u, object:$f) isa permission;
----

The above query inserts a user with email `john@email.com`, a file with path `insert.py`,
and a relation of the `permission` type between the new user and the new file.
It doesn't include any pre-existing data from a database.

Now let's do a match insert by adding a new file and a relevant permission for an existing user:

.Match insert
[,typeql]
----
match
    $u isa user,
        has email "john@email.com";
insert
    $f isa file,
        has path "match-insert.py";
    (subject:$u, object:$f) isa permission;
----

The above query matches all instances of `user` type with the email `john@email.com`.
Then, for every matched result (there should be only one result),
it inserts a new file `match-insert.py` and a new permission with the matched user and the inserted file.

To limit the number of inserts to exactly one, make sure the `match` clause has only one result.
The best way to do it is by matching a xref:typeql::schema/define-types.adoc#_unique_attribute[unique attribute],
like the `email` for the `user`.
See the <<_pera_schema,schema definition>> query.

The `insert` clause can be executed multiple times, if there are multiple matched results:

.Match insert with multiple inserts
[,typeql]
----
match
    $u isa user,
        has email "john@email.com";
    $f isa file;
insert
    (subject:$u, object:$f) isa permission;
----

The above query will match the user with the email `john@email.com` and every instance of the `file` type.
And for every result, consisting of the same user and a different file,
the `insert` clause is executed by inserting a `permission` relation.

== #{counter:query}: Deleting data

Deleting data from a database requires matching the data to delete.

[NOTE]
====
For the following query we use the data from the
<<_counterquery_inserting_data_with_or_without_context>> section.
====

.Delete permissions
[,typeql]
----
match
    $u isa user,
        has email "john@email.com";
delete
    (subject:$u) isa permission;
----

The above query will delete all permission relations for the user with `john@email.com` email.

== #{counter:query}: Inheritance

xref:typeql::fundamentals.adoc#_inheritance[Inheritance] lets subtypes use roles and attributes,
defined for their supertype (direct or nested).

include::typedb-in-20-queries.adoc[tag=preload]

.Inheritance
[,typeql]
----
define

person sub entity,
    owns full-name;
user sub person,
    owns email @unique,
    owns name @key;
employee sub user,
    owns employee-id;
employee-id sub id;
----

Given the schema above, we can use `employee` with inherited attributes and roles:

.Using inherited attributes
[,typeql]
----
insert
    $e isa employee,
        has employee-id "e1234",
        has email "kate@gmail.com",
        has full-name "Kate Smith";
----

In the query above we can insert an instance of `employee` type with `employee-id` and with some of the attribute types,
defined for its supertypes (`user` and `person`).
For example, `full-name` attribute can be owned by an instance of the `employee` type through inheritance.

== #{counter:query}: Overriding inheritance

You can override an inherited ownership or a role with a new name.
//#todo Add explanation as to why it might be needed

Override uses the keyword `as` with the new type preceding the keyword, and old (inherited) type following the keyword.

The new type should be defined in the schema as a subtype of the overriden (inherited) type.

[NOTE]
====
To run the following query, use an empty database.
====

.Override example
====
.Schema
[,typeql]
----
define

person sub entity, abstract,
    owns id,
    plays participation:participant;

user sub person,
    owns user-id as id,
    plays usage:user;

participation sub relation,
    relates participant;

usage sub participation,
    relates user as participant;

id sub attribute, abstract, value string;
user-id sub id;
----

In the above example, we override the inherited `id` attribute type with the `user-id` attribute type.
We also override the `participant` role, inherited by the `usage` relation with the `user` role.
====

== #{counter:query}: Polymorphic queries

Querying for a supertype will return all results for its subtypes.

include::typedb-in-20-queries.adoc[tag=preload]

[,typeql]
----
match
    $u isa user, has id $i;
----

The above xref:typeql::data/get.adoc[Get] query will return pairs of `$u` and `$i`:

* `$u` can be an instance of either the `user` type or any of its subtypes (e.g., `employee`),
* `$i` can be an instance of any subtypes of the `id` type.
  Since the `id` type is abstract, it can't be instantiated directly, only by subtyping.

[#_counterquery_extending_the_schema]
== #{counter:query}: Extending the schema
//subtyping
//adding a role-player
//adding attributes to entities

A schema of a TypeDB database can be extended at any time without the need to rewrite existing queries.
The easiest way to extend the schema is to add a new type, add an ownership of an attribute type, add a role, or
add an ability to play a new role with a xref:typeql::schema/define-types.adoc[Define] query.

include::typedb-in-20-queries.adoc[tag=preload]

.Schema extension variants
[tabs]
====
Add a new type::
+
--
[,typeql]
----
define

blocked sub attribute, value boolean;

action sub entity,
    owns name @key;
----
--

Add an ownership::
+
--
[,typeql]
----
define

user owns blocked;
----
--

Add a role::
+
--
[,typeql]
----
define

permission relates permited-action;
----
--

Add an ability to play a role::
+
--
[,typeql]
----
define

action plays permission:permited-action;
----
--

All together::
+
--
[,typeql]
----
define

action sub entity,
    owns name @key,
    plays permission:permited-action;

user owns blocked;

permission relates permited-action;

blocked sub attribute, value boolean;
----
--
====

== #{counter:query}: Abstract types

Abstract types can't be instantiated (no data can be inserted for the abstract type), but can be subtyped.

When inheriting ownership of an abstract attribute by a concrete type,
you need to override an abstract attribute with a concrete subtype of it.

.Overriding an abstract attribute example
[tabs]
=====
Default example::
+
--
To run the following query, use a database with the schema and data from the <<_pera>> section.

.Override example
[,typeql]
----
define

user owns id;
dude sub user,
    owns dude-id as id;

dude-id sub id;
----
--
Self-sufficient example::
+
--
To run the following query, use an empty database.

.Override example
[,typeql]
----
define

person sub entity, abstract,
    owns id;

user sub person,
    owns user-id as id;

id sub attribute, abstract, value string;
user-id sub id;
----
--
=====
//#todo Add inserting data?

== #{counter:query}: Relations with a single role
//n-ary
//nested
//variadic (1 role, many role players?)

A relation type can have one or multiple roles.
If there is only one role in a relation type, then all role-players are equal in the role they play in that relation.

One of the most popular examples of such a relation is friendship.
Every role-player in a friendship plays the same role: `friend`.

Every role can be played by zero, one, or many role-players.
An instance of a relation type with a role without any role players usually represents an incomplete data state.
Like a learning-course without a teacher, or marriage with only one spouse.

include::typedb-in-20-queries.adoc[tag=preload]

.Relation with a single role
[,typeql]
----
define

friendship sub relation,
    relates friend;

person plays friendship:friend;
----

In the above query we define the `friend` role of the `friendship` relation type.
The last line defines that the `person` type can play the `friend` role in the `friendship` type relations.
Other types can't play the role, unless it is defined in the schema.

.Example of a friendship relation
====
Let's xref:typeql::data/insert.adoc[insert] some friends:

.Inserting friends
[,typeql]
----
insert
    $p1 isa person, has full-name "Chandler":
    $p2 isa person, has full-name "Joey";
    ($p1, $p2) isa friendship;
----

In the above query we are inserting two entities, each owning one attribute,
and a relation of the `friendship` type between them.
Notably, we omitted roles in a relation insertion.
That is because there is only one role, that the `person` type instances can play in that relation.

Now let's add a third friend to the same `friendship` relation.

.Inserting one more friend
[,typeql]
----
match
    $p1 isa person, has full-name "Chandler":
    $p2 isa person, has full-name "Joey";
    $f($p1, $p2) isa friendship;
insert
    $p3 isa person, has full-name "Ross";
    $f($p3) isa friendship;
----

In the above query we match existing people from the database and a `friendship` relation between them.
For every matched result of two such people and a relation between them, the query inserts a third friend.

To retrieve the inserted relation and its role-players, use the following xref:typeql::data/get.adoc[Get] query:

.Retrieve all friends
[,typeql]
----
match
    $p isa person,
        has full-name $n;
    $f($p) isa friendship;
----

TypeDB Studio can visualize the result of the Get query as it is shown below.

image::typedb-in-20-queries/friendship.png[friendship, width=50%, link=self]
====

== #{counter:query}: Relations with multiple roles

A relation can have more than one role.
Having multiple roles means that role-players can play different roles in a relation.

In an N-ary relation type, every N-1 combination of roles should make sense.
For example, in a learning course relation type that relates a student, a teacher, and a location,
the relation between students and teacher also makes sense in the context of learning course.
As well as teacher/location, or student/location combinations.
There could be many people, each playing the `student` role in the same `learning-course` relation.

.Examples
[tabs]
=====
Learning course example::
+
--
.Schema
[,typeql]
----
define

learning-course sub relation,
    owns subject-name,
    relates teacher,
    relates student,
    relates location;

subject-name sub attribute, value string;

person
    plays learning-course:teacher,
    plays learning-course:student;

room sub entity,
    owns number,
    owns address,
    plays learning-course:location;

number sub attribute, value long;
address sub attribute, value string;
----

The `person` type instances can play at least two roles in a `learning-course` relation:
the `teacher` and  the `student`.
In this example, there are, most likely, multiple students, at least one teacher and at least one location.
There could be multiple teachers or locations for the same course.
If there is no role-players for the `teacher` or the `location` roles, then it's probably an incomplete data state.

.Inserting relation with multiple roles
[,typeql]
----
insert
    $t isa person, has full-name "Isabel Roth";
    $s1 isa person, has full-name "Martin Sloan";
    $s2 isa person, has full-name "Josie Sears";
    $s3 isa person, has full-name "Solomon Wallace";
    $r isa room,
        has number 304,
        has address "Wellington Square, Oxford OX1 2JD, UK";
    (location:$r, teacher:$t, student:$s1, student: $s2, student:$s3) isa learning-course,
        has subject-name "Computer Science";
----

The above query inserts three students, one teacher, one room,
and a learning-course relation with subject name `Computer science`.

With a delicate query adjustment (by changing the `insert` keyword
to the `match` and replacing all attribute values with variables),
TypeDB Studio can visualize the result as it is shown below.

image::typedb-in-20-queries/learning-course.png[learning-course, width=50%, link=self]
--
Movies example::
+
--
[,typeql]
----
define

cast sub relation,
    owns estimated-salary-usd,
    relates actor,
    relates movie-role,
    relates studio,
    relates movie;

actor sub person,
    plays cast:actor;
person sub entity,
    owns name;

movie sub entity,
    owns name,
    owns year-released,
    plays cast:movie;

movie-role sub entity,
    owns character-name,
    plays cast:movie-role;

name sub attribute, value string;
year-released sub attribute, value long;
character-name sub attribute, value string;
estimated-salary-usd sub attribute, value long;
----

In this example, usually there is one actor playing one or multiple roles in one movie with one or multiple studios.
And the relation itself has an attribute of estimated salary in USD.
--
=====
//#todo Add permission relation example

////
== #{counter:query}: Transitive relations

.Schema
[,typeql]
----
define

group-membership sub relation,
    relates group,
    relates group-member;

user plays group-membership:group-member;

user-group sub entity,
    owns name,
    plays group-membership:group,
    plays group-membership:group-member;
----

[,typeql]
----
insert



----


////

== #{counter:query}: Globally unique attributes

Only an attribute can have a value, and the value type is set by the attributes type definition.
An instance of an attribute type has a unique value among all instances of the same type.

[IMPORTANT]
====
There can be no other instance of the same type with the same value.
====

For example, if more than one person has the same name, they will all own the same name attribute with the value.

.Example of owning the same instance
=====

// tag::empty[]
[NOTE]
====
This example is self-sufficient and designed to run in an empty database.
====
// end::empty[]

Consider the following schema:

.Schema
[,typeql]
----
define

name sub attribute, value string;

person sub entity, owns name;
company sub entity, owns name;
movie sub entity, owns name;

connection sub relation,
    owns name,
    relates connected-to;

person plays connection:connected-to;
company plays connection:connected-to;
movie plays connection:connected-to;
----

The `name` attribute type can be owned by three different entity types and one relation type.

Let's insert some data.

.Insert data
[,typeql]
----
insert

$p1 isa person, has name "Bob";
$p2 isa person, has name "Bob";
$c isa company, has name "Bob";
$m isa movie, has name "Bob";

$con($p1, $p2, $c, $m) isa connection, has name "Movie production", has name "Bob";
----

In the above query create a single instance of the `name` attribute type with the value "Bob"
and insert ownership of it to instances of other types.
Notice that we didn't specifically create the attribute "Bob" of the `name` type.
We assigned ownership over it, and the attribute was created implicitly, because it didn't exist previously.

The relation we inserted has ownership over two attributes of the same type.
One of those attributes is the same "Bob",
and the second one was also implicitly created upon the first assignment of ownership.

Using TypeDB Studio, we can visualize the resulted data as the image below.

image::typedb-in-20-queries/unique-attributes.png[unique attributes, width=50%, link=self]
=====

== #{counter:query}: Immutable attributes

Attributes have values and are immutable.
We can't change the value of an attribute.
We can replace it with another attribute of the same type but a different value.

[IMPORTANT]
====
The value of an attribute can't be changed.
====

To change a value owned by some instance of a type,
we delete an ownership of the attribute with the old value form the type
and insert ownership of the new attribute with the new value.

For example, to change a name of a person,
we xref:typeql::data/delete.adoc[Delete] an ownership of old name
and xref:typeql::data/insert.adoc[Insert] ownership of the new one.
We can delete the old name itself (the attribute), but that would influence all people with that particular name.

.Attribute ownership example
====
.Schema
[,typeql]
----
define

name sub attribute, value string;
person sub entity, owns name;
----

.Insert data
[,typeql]
----
insert
    $p isa person, has name "Ken";
----

.Update name
[,typeql]
----
match
    $p isa person, has name "Ken";
delete
    $p has name "Ken";
insert
    $p has name "Kendra";
----

The above Update query matches the person with the old name,
then, for all matched results, deletes the name "Ken" and inserts the name "Kendra".
====

== #{counter:query}: Attribute annotations
//Key
//Unique

When defining an ownership of an attribute type, we can add one of possible annotations: `@key` or `@unique`.

The `@unique` annotation makes the ownership constrained by uniqueness.
That means, that instances of the owner type can't own any instance of owned attribute more than once.

The `@key` annotation makes the owned attribute a key for the owner type.
That applies the same constraint as uniqueness and a cardinality of exactly one,
meaning that all instances of the owner type must have exactly one instance of the owned attribute.

.Example
=====

include::typedb-in-20-queries.adoc[tag=empty]

Consider the following schema:

.Schema
[,typeql]
----
define

user sub person,
    owns email @unique,
    owns name @key;

name sub attribute, value string;
email sub attribute, value string;
----

In the schema xref:typeql::schema/define-types.adoc[Define] query above we define `name`

=====

== #{counter:query}: Regex
//define (constraint for the value that can be inserted)
//match (constraint for the valued matched)

[,typeql]
----
match
    $x isa full-name;
    $x like "(Masako Holley|Kevin Morrison)";
----

[,typeql]
----
define

status sub attribute, value string, regex "^(STARTED|STOPPED|DELETED)$";
----

== #{counter:query}: Arithmetic expressions



[,typeql]
----
define

file sub entity,
    owns path,
    owns size-kb;
size-kb sub attribute, value long;
----

[,typeql]
----
insert $f isa file, has path "config.yaml", has size-kb 35;
----

[,typeql]
----
match

$f isa file, has size-kb $s;
?mb = $s/1024;
?mb < 1;
----

== #{counter:query}: Rule-based inference



[,typeql]
----
define

person sub user;

rule every-person-is-a-dude:
    when {
        $p isa person;
    } then {
        $p has full-name "Dude";
    };
----

== #{counter:query}: Rule chaining



[,typeql]
----

----

== #{counter:query}: Rule transitivity


collection-membership sub membership,
relates collection as parent;

[,typeql]
----
define

rule collection-transitivity:
    when {
        $f isa file;
        $m2 isa collection-memebership;
        $m1(member:$f) isa collection-membership;
        $m2(member:$m1) isa collection-membership;
    } then {
        $m2($f) isa collection-membership;
    };
----

.Schema
[,typeql]
----
define

group-membership sub relation,
    relates group,
    relates group-member;

user plays group-membership:group-member;

user-group sub entity,
    owns name,
    plays group-membership:group,
    plays group-membership:group-member;
----

[,typeql]
----
insert



----

== #{counter:query}: Driver API schema modification
//based on Studio ???
//rename
//change a supertype
//etc.

//step-by-step guide for Studio


== #{counter:query}: Find all permissions for Kevin



[,typeql]
----

----





















// ==============================================================================================================
////
[#_abstract]
== #{counter:query}: Absract types

Define abstract entity, relation, and attribute types in your schema to extend concrete types from.
Build templates with ownership of abstract attributes and playing of abstract roles for subtypes to extend and override.

.Schema
[,typeql]
----
define

id sub attribute, abstract, value string;
email sub id;
path sub id;

user sub entity, abstract,
    owns id;
employee sub user,
    owns email as id;
resource sub entity, abstract,
    owns id,
    plays collection-membership:member;
file sub resource,
    owns path as id;

membership sub relation, abstract,
    relates parent,
    relates member;
team-membership sub membership,
    relates team as parent;
collection-membership sub membership,
    relates collection as parent;
----

Abstract types `id`, `user`, `resource`, and `membership` can't be used to insert data, but can be subtyped.

For more information on abstract types, see the
xref:typeql::schema/define-types.adoc#_abstract_types[abstract types] section on the
xref:typeql::schema/define-types.adoc[] page.

[#_inheritance]
== #{counter:query}: Type inheritance

Type inheritance in TypeDB allows you to create new types based on existing ones,
providing hierarchy and abstraction in your data model.
By inheriting attributes and relationships from parent types, schema design is simplified,
promoting reusability and consistency.

.Schema
[,typeql]
----
define

user sub entity,
    owns full-name,
    owns email;

intern sub user;

employee sub user,
    owns employee-id,
    owns title;

part-time-employee sub employee,
    owns weekly-hours;

full-name sub attribute, value string;
id sub attribute, abstract, value string;
email sub id;
employee-id sub id;
title sub attribute, value string;
weekly-hours sub attribute, value long;
----

For more information on how type inheritance works, see the
xref:typeql::fundamentals.adoc#_inheritance[inheritance] section on the
xref:typeql::fundamentals.adoc[] page.

[#_type_inference]
== #{counter:query}: Type Inference

TypeDB’s type inference resolves queries against the schema to generate polymorphic results.
Queries on supertypes automatically return results for subtypes,
and the types of variables can even be omitted to match only the shape of the data.

.Schema
[.typeql]
----
define

user sub entity, abstract,
    owns id,
    plays resource-ownership:owner;
employee sub user,
    owns employee-id as id;
resource sub entity, abstract,
    owns id,
    plays resource-ownership:resource;
file sub resource,
    owns path as id;
database sub resource,
    owns name as id;
commit sub resource,
    owns hash as id;
resource-ownership sub relation,
    relates resource,
    relates owner;
----

//#todo We can simplify this query - so it will not use variables for everything.
// It would be easier to understand the type inheritance with exact types used
.Polymorphic query
[,typeql]
----
match
    $user has id $user-id;
    $rsrc has id $rsrc-id;
    ($user, $rsrc) isa $relation-type;
----

This query retrieves data by a pattern, that variablizes almost all types, except `id`.
//#todo Add a link to learn more

[#_semantic_validation]
== #{counter:query}: Semantic Validation

TypeDB validates all queries and rules against the type system defined in the schema to ensure semantic correctness.
Nonsensical writes are automatically blocked,
and nonsensical reads throw an exception instead of returning an empty result set.

.Define schema
[,typeql]
----
define

weekly-hours sub attribute, value long;

user sub entity,
    owns full-name,
    owns email @unique;
employee sub user,
    owns employee-id @key;

full-time-employee sub employee;
part-time-employee sub employee, owns weekly-hours;
----

.Insert data
[,typeql]
----
insert $francois isa full-time-employee,
    has full-name "François Durand",
    has email "francois@vaticle.com",
    has employee-id 184,
    has weekly-hours 35;
----

The above query won't pass query validation for the `full-time-employee` can't have an ownership of the
`weekly-hours` attribute, because it was not defined in the schema.

.Error message example
[,bash]
----
[THW03] Invalid Write: Attribute of type 'weekly-hours' is
not defined to be owned by type 'full-time-employee'.
----

[#_rules]
== #{counter:query}: Rule-Based Reasoning

TypeDB’s symbolic reasoning enables the automated deduction of new facts and relationships
based on existing data and rules you define.
Rule chaining and branching allow complex behavior to arise from simple rules, creating rich, high-level insights.

.Rule examples
[,typeql]
----
define

rule transitive-team-membership: when {
    (team: $team-1, member: $team-2) isa team-membership;
    (team: $team-2, member: $member) isa team-membership;
} then {
    (team: $team-1, member: $member) isa team-membership;
};

rule inherited-team-permission: when {
    (team: $team, member: $member) isa team-membership;
    (subject: $team, object: $obj, action: $act) isa permission;
} then {
    (subject: $member, object: $obj, action: $act) isa inherited-permission;
};
----

For more information on rules, see the
xref:typeql::schema/define-rules.adoc[] page.

For more information on reasoning, see the
xref:typedb::development/infer.adoc[] page.

[#_explanations]
== #{counter:query}: Explanations

TypeDB's reasoning engine functions on deductive reasoning, so inferred data can always be traced back to its source.
Perform root-cause analysis using TypeDB’s Explanations feature, guaranteeing accountability of generated data.

[,typeql]
----
query = "match $perm isa inherited-permission;"

with open_session.transaction(TransactionType.READ) as tx:
    results = tx.query().match(query)
    for result in results:
        inherited_permission = result.explainables().relation("perm")
        explanations = tx.query().explain(inherited_permission)
        for explanation in explanations:
            condition = explanation.condition()
            rule = explanation.rule()
            conclusion = explanation.conclusion()
----

[#_variable_types]
== #{counter:query}: Variable Types

Schema types and relation roles can be variablized in addition to data instances,
making schema querying as easy as data querying.
Queries can contain both schema and data constraints,
allowing for patterns that represent highly complex conceptual structures.

[,typeql]
----
define
user sub entity, has full-name;
    plays mentorship:mentor,
    plays mentorship:trainee;
employee sub user;
contractor sub user;
mentorship sub relation,
    relates mentor,
    relates trainee;

match
$user isa $user-type, has full-name;
$user-type sub user;
($role-1: $user, $role-2: $other-user) isa mentorship;
mentorship relates $role-1, relates $role-2;
----

[#_Inheritance_polymorhipsm]
== #{counter:query}: Inheritance Polymorphism

TypeQL implements inheritance polymorphism,
allowing subtypes to inherit the behaviors of the supertypes they extend, whether concrete or abstract.
Write TypeQL queries that return results with a common supertype, without enumerating the subtypes.

[,typeql]
----
define
user sub entity,
    owns full-name,
    owns email @unique;
employee sub user,
    owns employee-id @key;

insert
$john isa employee,
    has full-name "John Doe",
    has email "john@vaticle.com",
    has employee-id 183;
----

[#_interface_polymorhpism]
== #{counter:query}: Interface Polymorphism

Ensure conceptual consistency between defined types and their behaviors in perfect parallel to your object model
by harnessing TypeQL’s interface polymorphism.
Types can own the same attributes and play the same roles, even if they share no common supertypes.

[,typeql]
----
define
name sub attribute, value string;
user sub entity, owns name;
team sub entity, owns name;
table sub entity, owns name;

match
$x has name;
----

== #{counter:query}: Parametric Polymorphism

Write queries that create or delete data instances without specifying their types by utilizing parametric polymorphism.
Queries are resolved against the schema when run,
allowing them to write data of multiple types matching declared properties.

[,typeql]
----
match
$data isa $T;
$data has data-expiration-date < 2023-09-27;

delete
$data isa $T;
----

== #{counter:query}: Near Natural Modern Language
//Modified heading to add language. Otherwise, it was too vague

Due to its OOP properties and simple syntax, queries written in TypeQL read close to natural language.
Domain experts and non-technical users alike can quickly grasp the intent of a query,
reducing the learning curve and making query maintenance a breeze.

[,typeql]
----
match
$kevin isa user, has email "kevin@vaticle.com";

insert
$chloe isa full-time-employee,
    has full-name "Chloé Dupond",
    has email "chloe@vaticle.com",
    has employee-id 185,
    has weekly-hours 35;
$hire (employee: $chloe, ceo: $kevin) isa hiring,
    has date 2023-09-27;
----

== #{counter:query}: Fully Declarative

TypeQL is fully declarative, allowing you to define query patterns without considering execution strategy. TypeDB’s query planner always deconstructs queries into the most optimized plans, so you never have to think about the logical implementation.

[,typeql]
----
define
user sub entity,
    owns full-name,
    owns email;
intern sub user;
employee sub user,
    owns employee-id;
full-time-employee sub employee;
part-time-employee sub employee,
    owns weekly-hour;
contractor sub user,
    owns contract-number;

match
$user isa $user-type;
$user-type sub user;
fetch
$user: attribute;
$user-type;
----

== #{counter:query}: Composable Patterns

Patterns in TypeQL are fully composable. Every complex pattern can be broken down into a conjunction of atomic constraints, which can be concatenated in any order. Any pattern composed of valid constraints is guaranteed to be valid itself, no matter how complex.

[,typeql]
----
match
$user isa user;

match
$user isa user;
$user has email "john@vaticle.com";

match
$user isa user;
$user has email "john@vaticle.com";
(team: $team, member: $user) isa team-membership;

match
$user isa user;
$user has email "john@vaticle.com";
(team: $team, member: $user) isa team-membership;
$team has name "Engineering";
----

== #{counter:query}: Nested Subqueries

Search for complex data structures with a single query and network trip using nested subqueries. Retrieve results for nested queries as a list or perform aggregations over them, including results for optional attribute matches.

[,typeql]
----
match $user is user;
fetch
$user: email, full-name, employee-id;
teams: {
    match
    (team: $team, member: $user) isa team-membership;
    fetch
    $team: name;
};
permission-count: {
    match
    $perm (subject: $user) isa permission;
    count;
};
----

== #{counter:query}: Structured Results

Query results can be serialized for easy consumption in your application with TypeQL’s native JSON outputs. Switch from an asynchronous answer stream to a single structured collection, and define the result format using projections in the query structure.

[,typeql]
----
match $user isa full-time-employee;
fetch $user as employee: attribute;
limit 1;

# JSON output:
[{
    "employee": {
        "type": { "root": "entity", "label": "full-time-employee" },
	"attribute": [
            { "value": "Chloé Dupond", "value_type": "string", "type": { "root": "attribute", "label": "full-name" } },
            { "value": "chloe@vaticle.com", "value_type": "string", "type": { "root": "attribute", "label": "email" } },
            { "value": 185, "value_type": "long", "type": { "root": "attribute", "label": "employee-id" } },
            { "value": 35, "value_type": "long", "type": { "root": "attribute", "label": "weekly-hours" } }
        ]
    }
}]
----

== #{counter:query}: Aggregates and Expressions

Perform basic mathematical operations directly in your queries or rules with aggregations and arithmetic expressions, enabling dynamic and efficient data computation.

[,typeql]
----
match
$user is user;
$perm (subject: $user) isa permission;
group $user;
count;

match
$dir isa directory,
    has path $path,
    has size $kb;
?gb = $kb / 1024 ^ 2;
get $path, ?gb;
----

== #{counter:query}: Query Builder

Use the TypeQL query builder to auto-generate queries using a code-first approach in Java or Rust, with other languages coming soon. This permits the generation of TypeDB queries through a robust and streamlined process.

[,typeql]
----
TypeQLMatch.Filtered builtQuery = TypeQL.match(
    cVar("user").isa("user").has("full-name", "Kevin Morrison"),
    cVar("file").isa("file").has("path", cVar("path")),
    cVar("perm").rel(cVar("user")).rel(cVar("file")).isa("permission")
).get(cVar("path"));

// builtQuery =
// match $user isa user, has full-name 'Kevin Morrison';
// $file isa file, has path $path;
// $perm ($user, $file) isa permission;
// get $path;
----
////

////
== #{counter:query}: Query Templates

Build query templates that accept a tuple of attribute values as parameters and execute them repeatedly for lists of supplied values. The template is stored in the transaction cache, reducing network load and ensuring sanitization of input strings.


[,typeql]
----

----
////

////
== #{counter:query}: N-ary Relations

Construct rich data representations by directly implementing unary,
binary, ternary, and n-ary relations in your conceptual model.
TypeQL’s expressivity allows you to use the same constructor format for all relations,
regardless of the number of roleplayers.

[,typeql]
----
match
$omar isa contractor, has email "omar@vaticle.com";
insert
$term (user: $omar) isa user-termination,
    has termination-date 2023-09-19,
    has termination-reason "end of contract";

match
$naomi isa user, has email "naomi@vaticle.com";
$eng isa group, has name "Engineering";
insert
$own (group: $eng, owner: $naomi) isa group-ownership;

match
$john isa user, has email "john@vaticle.com";
$readme isa file, has path "/usr/johndoe/repos/typedb/readme.md";
$edit isa action, has name "edit file";
insert
$perm (subject: $john, object: $readme, action: $edit) isa permission;
----

== #{counter:query}: Nested Relations

Relations are first-class citizens in TypeQL and so can own attributes and play roles in other relations just like entities. With no limit to the depth of nesting for relations, you can express the full richness of your data without reifying your data model.

[,typeql]
----
match
$john isa user, has email "john@vaticle.com";
$readme isa file, has path "/usr/johndoe/repos/typedb/readme.md";
$edit isa action, has name "edit file";
$perm (subject: $john, object: $readme, action: $edit) isa permission;
$kevin isa user, has email "kevin@vaticle.com";

insert
$rqst (target: $perm, requestee: $kevin) isa change-request,
    has requested-change "revoke";
----

== #{counter:query}: Variadic Relations

With TypeQL’s expressive relation constructor, you can easily implement relations where the same roleplayer plays multiple roles, multiple roleplayers play the same role, or a combination of both. Read queries always return all matched roleplayers.

[,typeql]
----
match
$submit isa action, has name "submit order";
$approve isa action, has name "approve order";
insert
(segregated-action: $submit, segregated-action: $approve) isa segregation-policy;

match
$kevin isa user, has email "kevin@vaticle.com";
insert
(reviewer: $kevin, reviewee: $kevin) isa permission-review;
----

== #{counter:query}: Cardinality Constraints

All attributes and relations have many-to-many cardinality by default. Apply constraints in the schema to apply stricter cardinalities wherever needed, with the expressivity to select a single value or a specific range.

[,typeql]
----
define

name sub attribute, value string;
object-type sub attribute, value string;

action sub entity,
    owns name @card(1),
    owns object-type @card(1,*)
    plays segregation-policy:segregated-action @card(0,*);

segregation-policy sub relation,
    relates segregated-action @card(2);
----

== #{counter:query}: Multi-Valued Attributes

TypeQL is a conceptual data modeling language, and all attributes have many-to-many cardinality by default. Giving an entity or relation multiple attributes of the same type is as simple as declaring them in an insert, and read queries automatically return all values.

[,typeql]
----
insert
$john isa full-time-employee,
    has primary-email "john.doe@vaticle.com",
    has email "j.doe@vaticle.com",
    has email "john@vaticle.com",
    has email "sales@vaticle.com";
----

== #{counter:query}: Globally Unique Attributes

Attributes are globally unique in TypeQL. If two entities each have an attribute with the same type and value, then they both have the same attribute instance. This allows for highly efficient data traversals, keeps disk usage low, and maintains a consistent model.

[,typeql]
----
insert
$roadmap isa file,
    has path "/vaticle/feature-roadmap.pdf",
    has confidentiality "public";
$cloud isa repository,
    has name "typedb-cloud",
    has confidentiality "restricted";
$sales isa database,
    has name "sales",
    has confidentiality "restricted";

match $rsrc has confidentiality $conf;
fetch $conf;
----

== #{counter:query}: No Nulls

Unlike SQL and NoSQL modeling languages, TypeQL is entirely conceptual and does not need to implement nulls to store the absence of a value. Keep nulls out of your query results without compromising for a schema-less database.

[,typeql]
----
insert
$john isa user, has full-name "John Doe";
$david isa user, has email "david@vaticle.com";

match $user isa user;
fetch $user: full-name, email;

# JSON output:
[{
    "user": {
        "type": { "root": "entity", "label": "user" },
        "full-name": [
            { "value": "John Doe", "value_type": "string", "type": { "root": "attribute", "label": "full-name" } }
        ],
        "email": []
    }
}, {
    "user": {
        "type": { "root": "entity", "label": "user" },
        "full-name": [],
        "email": [
            { "value": "david@vaticle.com", "value_type": "string", "type": { "root": "attribute", "label": "email" } }
        ]
    }
}]
----

== #{counter:query}: Attribute Constraints

Define a key constraint on an attribute to make ownership of that attribute required and ensure a unique value. Alternatively, use a unique constraint instead to ensure uniqueness without requiring ownership. Apply regex constraints to string attributes to enforce defined patterns.

[,typeql]
----
define
full-name sub attribute, value string;
office-location sub attribute, value string;
id sub attribute, value string;
email sub id;
employee-id sub id;
user sub entity,
    owns full-name,
    owns email @unique, regex "^(.+)@(\\S+)$";
employee sub user,
    owns employee-id @key,
    owns office-location, regex "^(London|Paris|Dublin)$";
----


////