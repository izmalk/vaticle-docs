= Data model
:Summary: PERA model for data modelling in TypeDB.
:keywords: typedb, data, model, modelling, pera, polymorphic
:pageTitle: Data model
:!example-caption:

Every TypeDB database has a schema that contains a data model of a database.
TypeDB uses a Polymorphic Entity-Relation-Attribute (or *PERA*) model with
`entity`, `relation`, and `attribute` being the built-in root types.
A type can be added to a schema by subtyping one of the existing types.
//Schema defines a supertype (or parent type) of every user-defined type, as well as some constraints: what roles it
//can play and what attributes own.

Data can be inserted into a database only as an instance of its schema's type.
Effectively, that makes all data stored in TypeDB separated into three major categories:
Entities, Relations, and Attributes.

If we are to provide an analogy,
types can be seen similar to classes used in OOP, and instances of types are like objects, or instances of classes.

//Mention ER-model comparison

== Entities
//Entity types?

Entities represent independent objects in a data model.
By creating a type hierarchy for entities,
we're effectively creating a classification system of independent objects in our domain.

An entity can play a role in a relation and can have ownership of an attribute.
An entity's type defines what roles in what relations it can play and what attributes it can own.
Entities can't have a value or reference other data instances.

== Relations

Relations represent relationships between data instances.
A relation can't exist without its roleplayers.

Roles of a relation are set in its type definition.
To play a role in a relation, a data instance must have this ability defined in a schema for its type.

== Attribute

Attributes represent properties with value that other types can own.

Attribute types have a value type, and instances of attribute types have a value.
This value is fixed and unique for every given instance of the attribute's type.





Other types can own an attribute type.
That means that instances of these other types can own an instance of this attribute type.
This usually means that an object in our domain has a property with the matching value.

An instance of an attribute type can be uniquely addressed by its type and value.

There can't be a second instance of the same type with the same value.

Multiple types can own the same attribute type -- and different instances of the same type or different types can
share ownership of the same attribute instance.






Roles of a relation can be played by any other data instance,
as long as its type defines the possibility of playing that role.




Relation types have roles.

Other types can play roles in relations if itâ€™s mentioned in their definition. An instance of another type
can be a role player for a role in the instance of a relation.

An instance of a relation can be uniquely addressed by a combination of its type, owned attributes, and role players.

A `relation` type must specify at least one role. A relation cannot be conceptualized without at least some of its
role players.








Instance of data of an entity type represents a standalone object that exists in our data model independently.

Instance of an entity type doesn't have a value.
It is usually addressed by its ownership over attribute instances and/or roles played in relation instances.

An object modeled with an entity type might practically require other entities to exist, such as a car that cannot
exist without its parts, but can be conceptualized without reference to those other entities: a car can be imagined
without considering its parts.









That


ERA stands for Entity, Relation, Attribute.
Those are three root types of a TypeDB database.
We can create


and we have




A type represents a set of constraints on the interpretation of data.

A type for a data instance is like a class for an object in OOP.

A definition of a type in a schema of a database sets:

* type hierarchy -- every user-defined type has only one parent or supertype.
* constraints -- what a type can do: what role to play, what attributes it can own, what value type it has
(attribute types only), and what roles it relates (relation types only).

A type can be addressed by its label (name). A type label is unique in a schema of a database.

We can define a new type only as a subtype of an existing one.

A new empty database has a set of built-in types. These built-in types are called root types because all user-defined
types will be subtypes (direct or non-direct) of those root types.

.Root (built-in) types
[cols="^.^1, ^.^3, ^.^4",options="header"]
|===
| Root type label | A subtype of the root type | An instance of data of a subtype

| `entity`
| Entity type
| Instance of entity type

| `relation`
| Relation type
| Instance of relation type

| `attribute`
| Attribute type
| Instance of attribute type
|===

[IMPORTANT]
====
All root types are <<_abstract_types,abstract>> types.

That's why when we say *entity type*, we usually mean a subtype of the `entity` root type.
In the same way, we can address *relation type* or *attribute type* instead of mentioning
subtypes of the root types.
====
// end::types_basics[]

[NOTE]
====
To avoid ambiguity when using type labels, we should try to provide context or specify what exactly
we mean:

- the type and all its subtypes (the default variant),
- the exact type, without any of its subtypes,
- or instances of data of this particular type and instances of data of all its subtypes.
====