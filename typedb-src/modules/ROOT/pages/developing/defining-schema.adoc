= Defining a schema
:Summary: How to define a schema for a TypeDB database.
:page-aliases: typedb::development/schema.adoc
:keywords: typedb, typeql, schema, define, undefine, type, rule
:pageTitle: Defining a schema

Before inserting any data into a database, we need to declare its data model.
In TypeDB that is done by defining a schema.

[#_schema]
== Schema

A TypeDB schema is like a blueprint of a database.
It consists of definitions for all types and rules used in a database.
Types follow the xref:typedb::basics/data-model.adoc[PERA model] to represent a business domain of a database.
Rules are defined with a special xref:typeql::schema/define-rules.adoc#_syntax[syntax]
that lets them use data statements to xref:typedb::developing/infer.adoc[infer] new data.

All queries are written with xref:typedb::basics/query-language.adoc[TypeQL]
and validated not only for their syntax, but also for type violations.
New types can be created by subtyping existing types.
Every subtype has a single parent (or supertype).
Subtypes inherit properties of their supertypes.
A definition of a type declares its supertype, as well as its own properties and constraints.
Query patterns can use xref:typedb::basics/polymorphic-patterns.adoc[polymorphism]
to retrieve data of different types, even those not mentioned in the patterns.

A newly created database has the <<_default_schema,default schema>> that can be extended by user-defined types.

[#_default_schema]
== Default schema

A database is created with the default schema,
that contains built-in xref:typeql::schema/define-types.adoc#_abstract[abstract]
types and cannot be deleted, but can be extended.
These built-in types include the root types: `entity`, `relation`, and `attribute`,
that can be subtyped to create a full hierarchy of types for a data model.

There are no rules in the default schema.

Built-in types are not shown in schema export results, as they are internal and similar for all TypeDB databases.

=== Thing type

Root types have a common supertype -- the `thing` type.
It is also an abstract type, but it can't be subtyped directly.
Instead, as all abstract types, the `thing` can be used in a xref:typedb::basics/polymorphic-patterns.adoc[polymorphic]
pattern as a part of a query.
See an example below.

.The thing type example
[,typeql]
----
match
$x isa thing;
get $x;
----

The `thing` is a common supertype for all types in a database, so the above query returns every `$x`
that is an instance of any root type: `entity`, `relation`, or `attribute`.

include::typedb::partial$thing-warning.adoc[]

== How to define a schema

There are multiple ways we can modify an existing schema of a TypeDB database:

* A xref:typeql::schema/define-rules.adoc[Define] query -- extend a schema by defining new types and rules.
* An xref:typeql::schema/undefine.adoc[Undefine] query -- truncated a schema by removing types and rules.
* xref:drivers::overview.adoc[TypeDB Drivers]
(see
xref:drivers::rust/overview.adoc[Rust],
xref:drivers::python/overview.adoc[Python],
xref:drivers::java/overview.adoc[Java], or
xref:drivers::nodejs/overview.adoc[Node.js]
) --
perform schema modifications via API methods, including renaming a type, changing type's supertype, etc.
* xref:typedb::connecting/studio.adoc[TypeDB Studio] --
perform schema modifications via GUI with Type Browser and Type Editor.

This page only covers TypeQL queries as the default way of interacting with a database.
For more information on other ways to modify a schema, see the links above.
TypeQL queries can be used with any TypeDB Client, including TypeDB Drivers.

=== Extending a schema

Any schema can be extended by adding new types, new properties to existing types,
as well as adding new rules or replacing existing rules.

We can do that with a Define query: for xref:typeql::schema/define-types.adoc[types]
and xref:typeql::schema/define-rules.adoc[rules] in a schema.

Let's define a simple hierarchy of entity types:

.Entity types hierarchy example
[,typeql]
----
define

subject sub entity;
user sub subject;
person sub user;
----

The above `Define` query uses one pre-existing type -- `entity` root type from the default schema.
So this query can be run with a new empty database.

We can extend the resulted schema by defining a new type and a new property:

.Adding new types and properties
[,typeql]
----
define

full-name sub attribute, value string;
person owns full-name;
----

The above query adds an attribute type and an ability to own it for the `person` type.
In doing so the query relies on the pre-existing type `person` and the root type `attribute`.
This query can be run only with a schema that already has a `person` type.

For more information on using complex statements with a comma,
see the xref:typedb::basics/polymorphic-patterns.adoc[] page.

We can further extend our schema by adding even more types and properties,
but this time, let's duplicate some of the existing definitions to make the query easier to read.

.Extending a schema
[,typeql]
----
define

credential sub attribute, value string;
id sub attribute, abstract, value string;
email sub id, value string;
full-name sub attribute, value string;

subject sub entity,
    abstract,
    owns credential;

person sub user,
    owns email,
    owns full-name;
----

The above query contains some of the definitions that already exist in our database, for example,
`subject sub entity`.




Now, let's extend our schema by adding some more types and properties to the entity types


=== Truncating a schema

=== Deleting a schema

There is no way of deleting a schema of a database, other than manually deleting user-defined types and all rules with
an Undefine query.
You can also delete the whole database.

=== Creating a new schema

There is no way of creating a new schema or deleting an existing one.
You can delete all user-defined types and all rules to revert the schema back to the default schema state.
It is usually easier to just delete the whole database and create a new one with the same name and the default schema.





=== Renaming types

=== Replacing rules

=== How to undefine a schema


To extend or modify any schema




To define or undefine anything in a TypeDB database schema, we need:

1. Build the TypeQL query string (see below on this page):
* See how to <<_define_types,define types>>;
* See how to <<_define_rules,define rules>>;
* See how to <<_undefine_types,undefine types>>;
* See how to <<_undefine_rules,undefine rules>>;
* See how to <<_modify_types, modify types>>
2. xref:connecting/overview.adoc#_clients[Connect] to a TypeDB database with a xref:connecting/overview.adoc#_sessions[SCHEMA session].
3. Run a proper query type (xref:typeql::schema/define-types.adoc[Define]/ xref:typeql::schema/undefine.adoc[Undefine])
in a xref:connecting/overview.adoc#_transactions[write transaction].
4. Commit the transaction to persist the changes.


[#_define_types]
== Define types

Any number of define statements can be combined in a single Define query, requiring only one `define` clause with only
one `define` keyword at the very beginning.

To define a type use the following syntax:

[,typeql]
----
define

<label> sub <parent type label>
    [(, abstract)]
    [(, owns <attribute type label> [@annotation])...]
    [(, plays <relation type label>:<role>)...];
----

The `define` keyword is used only once per query for any number of statements.

The `abstract` keyword makes the type xref:typeql::schema/define-types.adoc#_abstract[abstract].

The `owns` keyword defines an attribute ownership.

The `plays` keyword defines a role that this type can play.

.See examples
[%collapsible]
====
[,typeql]
----
define object sub entity;
----

In the above example we define the `object` type as a subtype of the `entity` type, which is a built-in root type.

Here is more complex example:

[,typeql]
----
define

object sub entity;
resource sub object;
file sub resource,
   owns path,
   owns size-kb,
   plays object-ownership:object;
----

If we try to run this example in an empty database it will throw an error, because the `path` and `size-kb` attribute
types we mentioned as owned by the `file` entity type actually need to exist in the schema.

They can be defined in the schema prior to our query (e.g., if we run this query on the database from the
xref:home::quickstart.adoc[Quickstart] page), or we can define them in the same query. To do that, use the following query
instead:

[,typeql]
----
define

object sub entity;
resource sub object;
file sub resource,
   owns path,
   owns size-kb,
   plays object-ownership:object;

path sub attribute, value string;
size-kb sub attribute, value long;

object-ownership sub relation,
   relates object;
----
====

[NOTE]
====
All types, mentioned in a type definition (owned attributes or relation that the type can play a role in) must exist
in the schema or be defined in the same query.
====

[#_define_entity_type]
=== Define an entity type

See the xref:_define_types[] section.

No specific syntax for entities.

For more information about entity types see the xref:typeql::fundamentals.adoc#_entity_types[Entity types] section in
xref:typeql::fundamentals.adoc[] page.

[#_define_relation_type]
=== Define a relation type

To define a relation type use the following syntax:

[,typeql]
----
define

<label> sub (<relation type label>)
   [(, abstract)]
   [(, owns <attribute type label> [@annotation])...]
   (, relates <role label>) [(, relates <role label>)...]
   [(, plays <relation type label>:<role>)...];
----

The `relates` keyword defines a role of the relation type. There must be at least one role for any relation type.

.See example
[%collapsible]
====
[,typeql]
----
define

ownership sub relation,
    relates owned,
    relates owner;

group-ownership sub ownership,
    owns ownership-type,
    relates group as owned;
----

In the above example we define:

* the `ownership` type as a subtype of the `relation` root type, with:
** `owned` role,
** `owner` role;
* and the `group-ownership` type as a subtype of the `ownership` type, with:
** `ownership-type` role,
** `group` role, overriding inherited `owned` role,
** inherited `owner` role.
====

For more information about relation types see the xref:typeql::fundamentals.adoc#_relation_types[Relation types] section in
xref:typeql::fundamentals.adoc[] page.

[#_define_attribute_type]
=== Define an attribute type

To define an attribute type use the following syntax:

[,typeql]
----
define

<label> sub (<abstract attribute type label>)
[(, abstract)]
, value <value type> [, regex "<regex-expression>"]
[(, owns <attribute type label> [@annotation])...]
[(, plays <relation type label>:<role>)...];
----

The `value` keyword is mandatory and used to define a value type for the attribute.

For more information about attribute types see the
xref:typeql::fundamentals.adoc#_attribute_types[Attribute types] section in
xref:typeql::fundamentals.adoc[] page.

[#_define_rules]
== Define rules

To define a rule use the following syntax:

[,typeql]
----
define

rule <rule-label>:
when {
    ## the conditions
} then {
    ## the conclusion
};
----

Rule label must be unique. Defining a rule with existing label will rewrite the old rule with the new one.

The condition definition goes inside the `when` clause.

The conclusion definition goes inside the `then` clause.

For more information about rules, see the xref:typeql::schema/define-rules.adoc[] page.

[#_undefine]
== Undefine

Undefine query is used to remove a type or a rule definition form a schema.

Any number of undefine statements can be combined in a single Undefine query, requiring only one `undefine` clause
with only one `undefine` keyword at the very beginning.

[#_undefine_types]
=== Undefine types

To undefine a type use the following syntax:

[,typeql]
----
undefine

<label> sub <parent type label>
    [(, owns <attribute type label> [@annotation])...]
    [(, plays <relation type label>:<role>)...];
----

The undefine `keyword` is used only once per query for any number of statements.

The `sub` keyword is used only to remove the type mentioned left from the keyword from a schema.
The parent type label must be a direct or indirect supertype.

The `owns` keyword undefines an attribute ownership.

The `plays` keyword undefines a role that this type can play.

.See examples
[%collapsible]
====
Let's define a few new types to undefine them later.

[,typeql]
----
define

tag sub attribute, value string;

connection sub relation,
   relates item;

item sub entity,
   owns tag,
   plays connection:item;
----

In the above example we define the `tag` attribute type, `connection` relation type with the `item` role,
and `item` entity type, that can owns `tag` attribute type and plays `connection:item` role.

To undefine an attribute ownership use the following query:

[,typeql]
----
undefine

item owns tag;
----

To undefine the ability to play the role `connection:item` use the following query:

[,typeql]
----
undefine

item plays connection:item;
----

To undefine the `item` entity type (remove it from the schema) use the following query:

[,typeql]
----
undefine

item sub entity;
----
====

[#_undefine_subtype]
[IMPORTANT]
====
To be able to remove a type we need to delete all instances of data and all subtypes of this type first.

The usage of `sub` keyword in the undefine query statement will remove the type on the left from the `sub` completely
from the schema regardless of any ownerships or roles mentioned for this type.
====

[#_undefine_rules]
=== Undefine rules

To undefine a type use the following syntax:

[,typeql]
----
undefine

rule <rule-label>;
----

== Modification

[#_modify_types]
=== Modify types

The define statements are idempotent. By sending the same define query twice or more times the very same resulting
schema must be achieved as if we send it only once. So types and/or rules will not be duplicated.

We can add ownership of an attribute, annotation to an ownership, or a role to play by just defining the add-on.

.See example
[%collapsible]
====
Let's define a new ownership for the `item` entity.

[,typeql]
----
define

item owns size;
----

In the query above we define an ownership of `size` attribute by the `item` type.
For the query to succeed, we need both the `item` and the `size` types to exist in the schema already.
====

=== Rename types

// tag::rename[]
To rename a type (to change its label), use the xref:typedb:ROOT:connecting/studio.adoc[TypeDB Studio] or
TypeDB Driver API methods.
// end::rename[]

=== Modify rules

To modify a rule xref:_define_rules[define a new rule] with the same label. It will overwrite the existing rule upon
commit.

== Learn more

After we define the schema of our database we can try xref:typedb::developing/write.adoc[writing] and
xref:typedb::developing/read.adoc[reading] data from the database.

In case there is no database schema ready yet, we can use the xref:attachment$iam-schema.tql[IAM schema,window=_blank]
to try all the queries.
